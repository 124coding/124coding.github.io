---
layout: single
title:  "C++_복사생성자와_정적_멤버"
categories: study
tags: [c++]
---


# 복사생성자와 정적 멤버
이번에는 함수가 객체를 받아들이고 반환하는 과정과 복사 생성자, 정적 멤버의 개념에 대해 학습하도록 하겠습니다. 복사 생성자란 동일한 클래스의 객체를 이용하여 새로운 객체를 만드는 방법으로 중요한 개념입니다.  

#### **함수로 객체 전달하기**
객체 지향 프로그래밍에서 함수 호출 시 객체를 전달하는 것은 빈번하게 일어나는 일입니다. 앞 전에서 배웠듯이 함수로 인수를 전달하는 방법은 2가지가 존재합니다.  
- 값에 의한 호출(call by value)
- 참조에 의한 호출(call by reference)

가장 기본적인 방법은 값에 의한 호출로 특별한 상황이 아니라면 항상 인수의 값이 매개 변수로 복사됩니다. 참조에 의한 호출은 변수의 주소나 변수의 참조자를 함수로 보내는 방법입니다. 

이번에는 함수에게 객체를 전달하거나 함수로부터 객체를 반환받으면 어떤 일이 일어나는지 확인해보겠습니다.  

**객체를 함수로 전달하기**  
다음과 같이 코드가 있다고 가정해보겠습니다.  

```C++
// 구현의 편리함을 위해 은닉화를 포기
class Circle{
public:
    int radius = 10;
}

void setRadius(Circle c){
    c.radius = 20;
};

int main(){
    Circle cir;
    setRadius(cir);

    return 0;
}
```

코드가 위와 같다면 cir 객체의 radius는 20으로 변환되었을까요? 아닙니다. 그렇다면 왜 바뀌지 않았을까요? 그 이유는 setRadius에서 받은 매개 변수는 값에 의한 호출로 복제된 cir의 복제품이기 때문입니다. 즉, cir이 아닌 새로운 객체 c가 만들어져 그 c의 radius가 20으로 바뀐 것이고 setRadius 함수가 종료되어 객체 c는 삭제된 것으로 cir은 아무런 변화도 일어나지 않은 것입니다.  

이때 이 c는 cir을 복제하여 생성되는 객체로 이때 사용되는 것이 바로 복사 생성자(copy constructor)라는 특수한 생성자입니다. 이러한 복사 생성자 또한 따로 작성하지 않으면 컴파일러가 알아서 기본적인 버전을 사용합니다. 복사 생성자의 자세한 내용은 이번 포스팅의 뒷부분에서 다루도록 하겠습니다.  

**객체의 주소를 함수로 전달하기**  
객체의 주소를 &연산자로 추출하여서 함수로 전달하면 이것은 객체가 아니기 때문에 생성자나 소멸자가 호출되지 않습니다. 그렇게 되면 객체 복사 시간도 없기에 속도도 빨라지며 함수 안에서 주소를 이용하여 원본 객체의 내용을 조작할 수 있게 됩니다. 여기서 이 방법의 장단점이 나왔습니다. 속도는 빠르지만 혹시 원치 않는 객체의 내용이 조작될 수 있다는 가능성이 있다는 것입니다. 그러나 이러한 문제는 프로그래머가 코드를 작성할 때 주의를 기울여서 사용하면 유용하고 강력한 기능으로 사용될 수 있습니다.  

```C++
class Circle{
    ...
}

void setRadius(Circle* c){
    c->radius = 20;
};

int main(){
    Circle cir;
    setRadius(&cir);

    return 0;
}
```

**참조자 매개 변수 사용하기**  
앞 전에서 참조자에 대해서도 설명드린 적 있습니다. 물론 객체를 매개 변수로 사용할때도 참조자를 이용할 수 있습니다. 참조자를 이용하면 코드를 더 간략하게 표현하는 것도 가능합니다.

```C++
class Circle{
    ...
}

void setRadius(Circle& c){
    c.radius = 20;
};

int main(){
    Circle cir;
    setRadius(cir);

    return 0;
}
```

#### **함수가 객체 반환하기**
그렇다면 함수가 객체 자체를 반환값으로 가지는 것도 가능할까요? 물론 가능합니다. 다음의 예시를 보겠습니다.  

```C++
void CreateRadius(){
    Circle c;

    return c;
}

int main(){
    Circle cir;
    cir = CreateRadius();

    return 0;
}
```

위처럼 코드를 작성하게 되면 어떤 일이 일어나게 될까요? 일단 먼저 답을 알려드리면 복사 생성자가 이용됩니다. 그렇다면 의아해하실 수도 있습니다. 어디에서 복사 생성자가 사용되는 거지? cir = CreateRadius()니깐 = 대입 연산자를 사용할 때 복사생성자가 사용되는걸까? 그건 아닙니다. 이건 연산자 오버로딩에 대한 얘기로 추후에 따로 학습할 내용입니다.  

그럼 복사 생성자는 어디서 사용될까요? 정답은 CreateRadius에서 return 즉, 반환을 시킬때 c 객체를 복사하고 그 복사된 객체를 반환하여 cir로 대입되는 것입니다. 이게 말로만 들으면 무슨 소리이신지 이해가 안가실수도 있습니다. 최대한 이해가 가시게 설명해보도록 하겠습니다.  

먼저 CreateRadius 함수 안에서 c라는 객체가 만들어집니다. 그런 후에 return c를 만나게 되면 복사생성자가 호출되는 것입니다. 이 복사 생성자가 호출이 되어 반환이 될 새로운 반환 객체를 만들게 되고 c는 소멸하게 됩니다. 그 후 이 반환 객체가 대입 연산자를 이용하여 cir에 대입되는 것입니다. 이는 처음에는 좀 이해가 안갈 수 있는데 보다보시면 이해가 되실 것입니다. 그렇다면 왜 이런 식으로 복사 생성자가 사용되는지 궁금하실 수 있습니다. 그 이유는 객체를 반환할 때 함수에서 만들어진 지역 객체가 사라지기 전에 그 내용을 안전하게 함수 외부로 전달하기 위해서입니다.  

함수가 호출되었을때 함수는 따로 스택 메모리에 가서 함수 안에서 만들어지는 모든 변수들을 그 공간에 저장하는데 이는 함수의 실행이 끝날 때 다같이 사라집니다. 당연히 안에 있던 지역 객체도 사라지기에 이를 안전하게 내보내기 위해 복사본을 만들어 함수를 호출한 쪽으로 전달하게 되는 것입니다.  

#### **복사 생성자**
복사 생성자(copy constructor)는 동일한 클래스의 객체를 복사하여 객체를 생성할 때, 사용하는 생성자입니다. 다음과 같은 형태가 바로 복사 생성자입니다.  

```C++
MyClass(const MyClass& other){
    ...
};
```

다음을 보시면 객체의 참조자를 상수의 형태로 매개 변수로 받는 것을 보실 수 있습니다. 왜 그럴까요? 일단 참조자를 받는다는 것은 매우 큰 의미가 있습니다. 만약 참조자없이 그냥 MyClass other로 매개 변수를 받는다면 그 내부적으로 또 복사 생성자를 부르고 거기서 또 복사 생성자를 부르는 무한 루프가 발생할 가능성이 있습니다. 그렇기에 참조자로 받는 것이 중요하고 참조자로 객체를 받으면 그 객체는 이 함수 내에서 수정이 가능하다는 의미가 됩니다. 이때 수정되는 것을 방지하기 위해 const 키워드를 사용하여 객체를 상수화시키는 것입니다.  

복사 생성자는 3가지의 경우에 호출이 됩니다.  
1. 같은 종류의 객체로 초기화하는 경우
2. 객체를 함수에 전달하는 경우
3. 함수가 객체를 반환하는 경우

만약 복사 생성자가 클래스 안에 정의되어 있지 않으면 컴파일러가 기본 복사 생성자를 정의합니다. 일반적인 경우 컴파일러가 알아서 정의하기에 의미가 없지만 클래스가 포인터 변수를 가지고 있고 동적 메모리 할당을 사용하는 경우에는 복사 생성자를 정의하는 것이 큰 의미를 가질 수 있습니다. 이에 대해 살펴보겠습니다.  

먼저 복사 생성자 정의가 필요 없는 경우입니다.  

```C++
class Circle{
public:
    int radius = 10;
};

int main(){
    Circle cir;
    Circle c(cir);

    return 0;
}
```

다음과 같이 작성하게 되면 복사 생성자가 호출되어 cir의 모든 멤버를 c로 복사하게 될 것입니다. 이때 호출되는 생성자가 바로 복사 생성자입니다. 컴파일러는 거의 모든 경우에 사용할 수 있는 복사 생성자를 자동 제공합니다.  

다음으로는 복사 생성자 정의가 필요한 경우입니다.  

```C++
class MyArray{
public:
    int size;
    int* data;

    MyArray(int s = 0) : size(s){
        this->data = new int[s];
    }

    ~MyArray(){
        delete[] this->data;
    }
};

int main(){
    MyArray arr(10);
    arr.data[0] = 1;

    {
        MyArray a(arr);
    }

    arr.data[1] = 2;

    return 0;
}
```

코드를 다음과 같이 작성하면 분명 오류가 발생할 것입니다. 왜 그럴까요? 그 이유는 arr.data[1] = 2를 할 때 포인터가 가리켜야 할 data가 없어졌기 때문입니다. 그렇다면 왜 없어진걸까요? 차근차근 살펴보겠습니다. 먼저 arr 객체가 생성자에 의해 생성되어 data[0]의 값을 1로 해주었습니다. 그 후 보면 {} 블록 안에 a가 복사 생성자를 이용하여 arr을 복사하여 생성되었는데 {} 블록이 끝이 나면서 a 객체는 삭제되게 됩니다. 그 후 arr.data[1] = 2를 하려고 하는데 data 포인터가 delete 되어버렸기에 arr 객체에서도 없어지는 것입니다.  

이것은 복사 생성자를 이용하여 포인터같은 동적 할당 메모리를 복사할 때는 새로 만드는 것이 아닌 같은 곳을 가리키게 하기 때문에 그렇습니다. 즉, 주소 값을 복사해왔기에 결국 같은 데이터를 가리키게 되는 것이고 이를 delete했다는 것은 그 주소 값의 데이터들을 삭제했다는 뜻이기에 더 이상 arr의 data가 가지고 있는 주소에는 들어있는 값들이 존재하지 않게 되는 것입니다. 그렇기에 더 이상 가리킬 곳이 없는 data가 값을 바꾸려고 하다보니 오류를 발생시키는 것입니다.  

이러한 문제를 얕은 복사(shallow copy)라고 하며 이를 해결하기 위해서는 깊은 복사(deep copy)를 이용해야 합니다. 이때 깊은 복사를 이용하기 위해 복사 생성자를 따로 정의해주게 되는 것입니다.  

```C++
class MyArray {
public:
    ...
    MyArray(const MyArray& other) {
        this->size = other.size;
        this->data = new int[other.size];

        for (int i = 0; i < other.size; i++) {
            this->data[i] = other.data[i];
        }
    }
    ...
};

int main(){
    ...
}
```

다음과 같이 복사 생성자를 정의하여서 새로운 메모리 공간을 할당받은 후에 매개 변수로 받는 객체의 데이터를 복사하여 주면 각 객체가 모두 별도의 동적 메모리를 할당받아서 사용하는 관계로 이전과 같은 오류가 발생하지 않게 됩니다.  

#### **복사 생성자 vs 대입 연산자**
이미 생성된 객체를 다른 객체에 복사하는 경우에는 복사 생성자가 호출되는 것이 아닌 대입 연산자가 호출됩니다. 다음과 같은 상황들을 보이겠습니다.  

```C++
MyClass a; // 기본 생성자
MyClass b = a; // 복사 생성자
MyClass c(a); // 복사 생성자
MyClass d{a}; // 복사 생성자
MyClass e; // 기본 생성자
e = a; // 대입 연산자
```

객체끼리도 대입 연산자를 이용하여 복사가 가능합니다. 위처럼 e = a라고 작성하게 되면 a의 모든 멤버 변수의 값이 e로 복사되게 되는 것입니다. 이런 대입 연산자는 개발자에 의해 재정의될 수 있습니다. 이는 추후에 학습토록 하겠습니다.  

#### **클래스 안에 객체 포함하기**
객체 지향 언어의 장점 중 하나는 코드의 재사용입니다. 객체 지향에서는 코드를 재사용하는 2가지의 방법이 있습니다.  
- is-a 관계: 상속을 기반으로 하는 관계
- has-a 관계: 하나의 객체가 다른 객체를 가지는 관계

위의 두 가지 관계에 대해 예시를 들자면 is-a는 Apple은 Fruit이다.처럼 큰 상위 개념에 포함되는 하위 개념같은 느낌이라고 생각하시면 되며 has-a는 Car에는 Engine이 있다.처럼 하나의 객체가 다른 객체를 포함하는 관계라고 생각하시면 됩니다.  

#### **정적 변수**
다음과 같은 경우를 생각해보겠습니다. 하나의 클래스를 작성하여 이 클래스가 객체를 만들때마다 수를 세서 현재 몇 개의 객체가 만들어졌는지 확인을 하고 싶습니다. 이럴 때는 어떻게 할 수 있을까요? 물론 전역 변수로 count를 지정해서 사용하는 방법도 존재할 것입니다. 그러나 이는 번거롭게 사용될 수 있습니다. 클래스 내부에 따로 변수를 두고 사용하고 싶은데 클래스에서 작성된 멤버 변수들은 객체를 만들때마다 그 객체에 맞게 값을 가지게 되기에 그것 또한 작성하기가 굉장히 번거로울 것입니다. 이때 사용할 수 있는게 static 키워드로 static 키워드로 작성된 변수는 정적 변수(static variable)이라고 불리며 클래스마다 한 개만 존재하게 됩니다.  

클래스의 모든 객체가 이 변수는 하나만을 공유하게 되는 것입니다. 다음과 같이 클래스를 작성하여 확인해보겠습니다.  

```C++
class MyClass{
    int a;

public:
    static int count;
    MyClass(int a = 0) : a(a){
        count++;
    }

    ~MyClass(){
        count--;
    }
};
```

위처럼 작성하게 되면 이제 MyClass 클래스의 객체가 생성될때마다 count가 +1 되어 현재 이 클래스의 객체가 몇 개인지 확인할 수 있을 것입니다. 그렇다면 count의 초기화는 어떻게 할까요? 저렇게만 사용하면 분명 오류를 부르게 될 것입니다.  

```C++
int MyClass::count = 0;
```

정적 변수의 초기화는 다음과 같이 클래스 밖에서 이루어지면 클래스 이름을 앞에 작성해주어야 합니다. 또한 다른 함수에서 count에 접근할때도 앞에 클래스 이름을 붙여주면 됩니다. 물론 public 접근 지정자로 선언되었을때를 말하는 것입니다.  

```C++
int main(){
    ...
    cout << MyClass::count;
    ...
}
```

**정적 멤버 함수**  
이번에는 정적 멤버 함수에 대해서 설명하겠습니다. 멤버 함수 또한 static 키워드를 이용하여 정적 멤버로 만들 수 있습니다. 정적 변수와 마찬가지로 클래스 이름을 앞에 붙여서 호출이 가능하며 객체가 만들어지지 않아도 호출이 가능합니다.  

정적 멤버 함수는 정적 멤버 변수가 아닌 일반 멤버 변수들은 사용하지 못하는 특징을 가집니다. 당연하게도 아직 생성되지 않은 객체의 멤버 변수들을 가져다 사용하는 것은 말이 안되기 때문입니다. 그렇기에 정적 멤버 변수와 지역 변수만을 사용할 수 있는 것이고 만약 실수로라도 일반 멤버 변수를 사용하거나 일반 멤버 함수를 호출하게 되면 오류가 발생하게 됩니다. 정적 함수에서 정적 함수를 부르는 것은 가능합니다. 또한 정적 멤버 함수는 this를 부를 수 없습니다. 왜냐하면 this가 가리키는 객체가 없기 때문입니다.  

**정적 상수**  
정적 멤버로 많이 정의되는 것은 바로 상수입니다. 상수는 클래스의 모든 객체들이 공유하며 정적 멤버로 선언하면 각 객체마다 저장할 필요 없이 모든 객체를 통틀어 하나만 존재하게 되기 때문입니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*


