---
layout: single
title:  "C++_기초사항"
categories: study
tags: [c++]
---

# 프로그래밍과 프로그래밍 언어
#### **프로그램**이란?  
프로그래머가 만드는 프로그램이란 우리가 하고자 하는 작업을 컴퓨터에게 전달하여 주는 역할을 하는 것입니다. 즉, 무엇을 어떻게 시킬 것인지 기록해놓은 작업 지시서라고 생각할 수 있습니다. 프로그램의 안에는 무엇을 어떤 식으로 해라같은 명령어(instruction)들이 들어있게 됩니다.  

그렇다면 컴퓨터에게 작업을 시킬때는 사람이 사용하는 자연어로 시키면 될까요? 아닙니다. 그러면 컴퓨터는 명령을 알아듣지 못하고 수행하지 못하게 될 것입니다. 컴퓨터가 이해할 수 있는 언어는 오직 한가지로 그것은 0과 1로 이루어진 기계어(machine language)입니다. 
실제로 초기에는 이런 기계어로 코딩을 하였습니다.

#### **프로그래밍 언어**  
그러면 기계어로 프로그램을 만들면 아무런 문제도 없지 않을까요? 아쉽게도 기계어는 인간의 언어와는 너무나도 다릅니다. 이를 이용하여 프로그램을 만드는 것은 인간에게는 상당히 불편할 수 밖에 없습니다.  
이러한 조건으로 인해 인간도 이해하기 쉬운 프로그래밍 언어라는 것이 만들어지게 된 것입니다.  
프로그래밍 언어는 자연어와 기계어 중간 어딘가에 존재하여 컴파일러라는 소프트웨어가 프로그램을 기계어라 바꿔주는 역할을 합니다.  
이런 식으로 프로그래밍 언어를 기계어로 바꾸는 일을 **컴파일**(compile)이라고 하며 이 작업을 수행하는 소프트웨어를 **컴파일러**(compiler)라고 합니다.

# C++
C++라는 이름에서 알 수 있듯이 C++는 C언어에 객체 지향 프로그래밍 기능을 추가하여서 만든 언어입니다. 이는 C처럼 절차지향 프로그래밍(procedural programming)도 가능하고 복잡한 프로그램 작성의 경우 객체 지향 프로그래밍(object-oriented programming)도 가능하며 템플릿을 이용한 일반화 프로그래밍(generic programming) 기능까지도 추가되어 사용할 수 있다는 의미가 됩니다. C++는 현재까지도 고성능 소프트웨어 개발을 위한 탁월한 언어 중 하나로 게임 개발, 운영체제 등 다양한 종류의 소프트웨어를 제작할 수 있습니다.  

C++의 가장 큰 특징으로는 C언어의 거의 모든 것을 지원하면서 객체 지향을 추가하였다는 점이다. 구체적으로 다음과 같은 기능들이 추가되었는데
- 클래스(class): 하나의 객체의 속성과 동작들을 한곳으로 모아서 정의
- 상속(inheritance): 클래스를 상속받아서 기존의 코드 재사용
- 다형성(polymorphism): 동일한 함수가 객체의 종류에 따라서 다르게 동작하는 것
- 연산자 중복(operator overloading): 대상에 따라서 동일한 연산자로 새로운 연산 정의
- 참조 타입(reference type): 변수의 별명을 만들어서 변수와 같이 사용
- 훨씬 큰 라이브러리: C와는 비교도 안될 풍부하고 방대한 표준 라이브러리를 제공
- 함수 중복(function overloading): 매개 변수만 다르면 동일한 이름의 함수를 여러 개 만들기 가능
- new와 delete 연산자: 동적 메모리 할당과 해제를 담당하는 연산자
- 제네릭(generic): 클래스 정의를 자료형에 상관없이 재사용

C++는 현대적인 C++로 변화하였고 C++의 요구 사항 중 하나는 C언어와의 호환성으로 이 유산으로 인해 C++은 종종 다중 패러다임 프로그래밍 언어라고 불립니다. C++에서는 원시 포인터, 배열, NULL 종료 문자열, 사용자 지정 데이터 구조 등이 그대로 남아 있어서 순전히 절차적인 C-스타일 프로그래밍을 하게 될 수도 있습니다. 이러한 것은 객체 지향 프로그래밍을 포기하는 것으로 주의를 요하게 됩니다.  

다음은 최근의 C++에 추가된 내용입니다.  
- 자동 타입 추론 (auto)
- 범위 기반 루프
- 람다식
- 스마트 포인터
- 벡터, 목록 및 맵과 같은 표준 템플릿 라이브러리 (STL) 컨테이너
- STL 알고리즘
- std::string 및 str::wstring 형식
- 오류 조건을 보고하고 처리하는 예외
- STL std::atomic<>(<atomic> 참조)를 사용하여 잠금 없는 스레드 간 통신

#### **C++를 사용하는 이유는?**  
왜 사람들은 C++를 사용하는 것일까요? C++는 초보자가 배우기 쉽지 않고 객체 지향을 제공하는 더 쉬운 파이썬과 자바도 존재해서 이를 쭉 사용하면 안되는 것일까요? 파이썬과 자바는 많은 부분을 런타임(실행시간)에 처리하게 됩니다. 예를 들어서 메모리 중 사용이 끝난 공간을 자동적으로 모아주는 기능(가비지 콜렉터)를 실행시간에 수행하기에 이는 큰 속도 저하를 일으키지만 프로그래머는 편하게 코딩을 할 수 있다는 장점이 있습니다.  
그러나 C++는 다릅니다. C++는 많은 부분을 컴파일 시에 처리하기에 작성이 비교적 힘들다는 단점이 있지만 성능을 중요시하기에 C++를 사용하는 것입니다.  

C++의 장점 몇가지를 들어보자면
- C++로 작성된 프로그램은 속도가 빠름.
- C++은 멀티패러다임 프로그래밍 지원. 즉, 절차지향, 객체 지향, 제네릭을 동시에 지원
- 하드웨어 접근 가능
- 메모리를 효율적으로 사용
- C언어 프로그램을 그냥 가져다 사용 가능

#### **절차 지향 vs 객체 지향**
절차 지향 프로그래밍(procedural programming)은 프로그래밍이 함수로 이루어져 작동하는 것을 말합니다. 여기서 함수는 명령어들의 모임으로 단순히 실행되어야 하는 일련의 명령어들을 포함하고 있습니다. 프로그래머는 언제든지 이 함수들을 호출하여 사용할 수 있게 됩니다. 기본적으로 C언어가 절차 지향 언어로 코드 자체가 함수들로 이루어져 있습니다.  

절차 지향 프로그래밍이 주어진 작업들을 함수로 분리하게 된다면 객체 지향 프로그래밍(object-oriented programnming)은 주어진 작업들을 객체(object)로 분리합니다. 여기서 객체란 우리의 일상생활과 같이 다양한 사물, 사람 등 각각을 표현하는 것입니다. 이렇듯 소프트웨어도 객체 단위로 작성하는 방법이 바로 객체 지향 프로그래밍입니다. 객체들은 객체 나름의 고유한 기능을 수행하면서 다른 객체들과 상호작용하게 됩니다.  

# C++ 예제 프로그램 분석
```C++
// 예제 프로그램
#include <iostream>
using namespace std;

int main(){
    cout << "Hello World!" << endl;
    return 0;
}
```

#### **// 예제 프로그램**
이 문장은 주석(comment)으로 코드를 설명하는 글입니다.  
주석은 프로그램의 실행에는 영향을 주지 않고 코드를 설명하기 위해 사용됩니다. 주석을 표현하는 방법으로는 한 줄 주석인 //이 있고 여러 줄 주석인 /* ... */이 있습니다.  

#### **#include <iostream>**
이 문장은 iostream이라는 헤더 파일을 포함시키라는 전처리기(preprocessor) 지시어입니다. iostream 헤더 파일에는 표준 입출력에 필요한 클래스들과 객체들이 정의되어 있습니다. 입출력을 위하여 cin, cout과 같은 객체를 사용하려면 반드시 iostream 파일을 포함시켜야 합니다. 그럼 이때 include가 어떻게 동작하는건지 궁금하실 수 있습니다. 컴파일 시간에 iostream의 소스 코드 내용을 현재 소스코드로 가져와서 작성하는 것입니다.  

또한 전처리기 지시어란 소스 코드 최상단에 위치하여 소스 코드가 컴파일될때 가장 먼저 수행되는 것으로 이름 그대로 '전'처리를 하는 것입니다. 이 전처리기 키워드들의 종류는 다음과 같은데
- #include: 포함시키다의 의미로 외부에서 선언되 다양한 파일, 소스코드, 라이브러리를 포함시킬 때 사용
- #define: 정의한다는 의미로 함수나 상수들의 심볼릭화, 매크로화 다양한 인자들에 대한 정의를 해줄 때 사용
- #undef: #define으로 정의된 내용들을 삭제하기 위해 사용
- #pragma: 프로그램의 이식성을 위해 특수한 상황을 컴파일러에게 알려줄 때 사용
- #if / #ifdef / #ifndef, #elif, #else, #endif: 조건부 컴파일 지시 키워드로 컴파일러에게 소스 코드의 컴파일 영역을 알려줌

이러한 전처리기들을 잘 사용한다면 불필요한 소스코드를 줄여 좋은 소스코드 구성을 만드는데 도움을 줄 수 있습니다.  

#### **using namespace std;**
C++ 프로그램에서는 변수 이름이나 함수 이름과 같은 수많은 이름(식별자)들이 사용되고 이들 이름들은 이름 공간(name space)이라고 하는 영역으로 분리되어 저장됩니다. 이름 공간이 다르면 동일한 이름이라도 사용할 수 있습니다. 예를 들면 a라는 이름 공간과 b라는 이름 공간에 둘 다 print() 함수가 있다면 이는 서로 다르게 사용할 수 있습니다. 이를 사용할 때는 a::print, b::print 즉, 공간::이름과 같이 공간명을 이름 앞에 붙혀야 한다는 원칙이 있습니다.  
그러나 매번 공간을 이름 앞에 붙이는 것은 번거롭기에 이를 해결하기 위해 using 지시어를 이용할 수 있습니다.  

```C++
// 기본적으로 작성하는 cout
std::cout << "Hello World!" << std::endl;

using namespace std;

// 앞에 using namespace std;를 붙혔을 때
cout << "Hello World!" << endl;
```

#### **int main()**
이 문장은 main() 함수를 정의하는 문장으로 함수(function)란 특정한 작업을 수행하는 코드의 집합입니다. 함수는 입력이 주어지면 출력을 만들어내는 블랙박스와 같습니다.  
하나의 프로그램은 여러 개의 함수로 이루어지게 됩니다. 이 중 main() 함수는 특별한 의미를 가집니다. 이는 프로그램의 진입점으로 프로그램의 시작을 담당하는 함수입니다. 그렇기에 프로그램은 늘 하나의 main()함수는 가져야 합니다.  

이제 이 main()함수를 분해해서 확인해보겠습니다. main() 앞에 붙은 int는 함수의 반환 타입으로 이 함수는 정수를 반환함을 의미하는 것입니다. 함수의 타입들에 대해서는 뒤에서 다루겠습니다.  

함수의 몸체는 {로 시작하여 }로 끝나게 됩니다.  

#### **cout << "Hello World!" <<endl**
이 문장은 콘솔 화면에 "Hello World!"를 출력하라는 의미로 cout은 콘솔 화면에 데이터를 출력하는 작업을 맡은 객체입니다. 화면에 데이터를 출력하려면 cout과 << 연산자를 사용하면 됩니다. 그 어떤 종류의 데이터라도 << 연산자로 출력 가능합니다. endl은 (end of line)을 출력하는 문장으로 현재 문장의 출력을 끝내고 다음 문장으로 넘어가는 줄바꿈을 담당합니다. 이는 '\n'과 동일하다고 생각하면 됩니다.  

#### **return 0;**
return은 함수가 작업을 끝내고 결과를 반환할 때 사용됩니다. return 0는 정수 0을 반환한다는 의미로 main()함수는 작업을 끝내고 외부로 0을 반환하는데 이때 반환 대상은 이 프로그램을 실행시킨 윈도우와 같은 운영체제로 보통 0의 값은 정상 종료되었음을 의미합니다.  

# 변수와 자료형
변수(variable)이란 데이터(값)를 저장하는 상자입니다. 변수들은 식별을 위하여 이름을 가지고 있습니다.  
변수는 사용 전에 반드시 다음과 같이 선언을 필요로 하게 됩니다.  
```C++
// 자료형, 변수 이름
int i;
```

변수가 가지는 값은 언제든지 수정이 가능합니다.  
```C++
i = 1; // i에 1을 저장한다.

...

i = 100; // i에 100을 저장한다.
```

변수를 선언과 동시에 초기화할려면 다음과 같이 작성할 수 있습니다.
```C++
int i = 100;

// 보편적인 초기화 방법
int i { 100 }; // int i = 100;과 동일
string s { "hello" }; // string s = "hello";와 동일

cout << i; // i를 출력
```

변수는 상자와 같다고 하였습니다. 이러한 상자는 다양한 종류가 있듯이 변수도 다양한 종류가 존재하며 정수를 저장할 수 있는 변수도 있고 실수를 저장할 수 있는 변수도 있습니다. 이러한 데이터의 종류를 자료형(data type)이라고 합니다.  

자료형을 크게 나누면 정수형, 부동 소수점형, 문자형, 부울형으로 나눌 수 있습니다.  

#### **자료형 세분화**
```
정수형
- short: short형 정수로 바이트 수는 2 범위는 -32768 ~ 32767
- int: 정수로 바이트 수는 4 범위는 -2,147,483,648 ~ 2,147,483,647
- long: long형 정수로 바이트 수는 4 범위는 -2,147,483,648 ~ 2,147,483,647
- long long: 64비트 정수로 바이트 수는 8 범위는 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

문자형
- char: 문자 및 정수로 바이트 수는 1 범위는 -128 ~ 127

부울형
- bool: 참이나 거짓을 나타내는 자료형으로 바이트 수는 1 범위는 true, false

부동소수점형
- float: 단일정밀도 부동소수점으로 바이트 수는 4 범위는 1.2E - 38 ~ 3.4E38
- double: 두배정밀도 부동소수점으로 바이트 수는 8 범위는 2.2E - 308 - 1.8E308
- long double: 두배정밀도 부동소수점으로 바이트 수는 8 바이트 수는 8 범위는 2.2E - 308 - 1.8E308
```
이는 64bit 윈도우를 기준으로 하고 있습니다.  

#### **문자열**
C++는 문자열을 위한 string 타입을 제공합니다. string 타입을 이용하면 문자열을 결합시킬때 + 연산자를 이용하여 매우 쉽게 할 수 있게 됩니다.  

이러한 string을 포함시키기 위해서는 string 헤더 파일을 필요로 합니다. 이 헤더 파일을 포함시키는 방법은 앞 전에 설명드렸듯이 include를 이용하면 됩니다.  

#### **기호 상수**
변수 선언 앞에 const를 붙이면 변수의 값이 변경되지 않음을 나타냅니다. 즉, 상수가 되는데 이것을 기호 상수라고 합니다.  
```C++
const double MAX = 100; // 기호 상수 선언
```
이러한 기호 상수는 상수 값을 그대로 사용하는 방법에 비해 몇 가지 장점을 가지게 됩니다.
1. 프로그램을 읽기 쉬워진다.
2. 동일한 상수를 여러 곳에서 사용하는 경우에 상수 값을 변경하기가 쉽다.

#### auto
auto란 자동 타입 추론(automatic type deduction)을 위한 키워드입니다. 자동 타입 추론에 대해 예를 들어서 설명드리겠습니다.  

```C++
double f = 1.0f;
```

다음과 같이 1.0f를 저장하는 double형 변수 f가 있다고 하겠습니다. 여기서 프로그래머가 f를 double이라고 선언하였지만 컴파일러는 이미 1.0f만을 보고 double 형이라는 것을 알아차렸을 것입니다. 이런 경우에는 자료형을 생략할 수 있고 이것이 바로 자동 타입 추론이며 이때 사용하는 키워드가 auto인 것입니다.

```C++
auto f = 1.0f;
```

이러한 auto 키워드는 함수를 정의할 때도 사용이 가능합니다. 앞전에 return 키워드에 설명한 적이 있는데 이러한 반환형을 auto로 함으로 반환 타입을 추론 시킬 수 있게 되는 것입니다.  

```C++
auto sum(int a, int b){
    return a + b;
}

int main(){
    auto sum = add(5, 6); // add는 정수를 반환함으로 자동으로 int형이 됨.
    return 0;
}
```

# 출력과 입력
C++에서 출력과 입력은 어떻게 할 수 있을까요? 앞전에 cout 즉, 출력에 대해서 언급한 적이 있습니다. cout은 콘솔에 데이터를 출력하는 작업을 맡고 있는 객체로 << 연산자와 함께 사용되어 출력할 대상을 받으면 그 대상을 출력하게 됩니다.  

그렇다면 입력은 어떤 객체가 담당하게 될까요? 입력은 cin이라는 객체가 담당합니다. cin을 사용하려면 >> 연산자와 함께 사용되게 됩니다.  

```C++
cin >> n;
```
다음과 같이 코드를 작성하면 사용자로부터 n의 변수값을 받겠다는 의미가 됩니다. 이때 cin도 변수의 타입에 따라서 자동적으로 입력 형식이 결정되게 됩니다. 즉, n이 int형이라면 int형을 입력 받고 string형이라면 string형을 입력 받게 되는 것입니다.  

# 수식과 연산자
c++는 상당히 많은 종류의 연산자를 제공합니다. 연산자가 많다는 것은 그만큼 데이터 가공 능력이 탁월하다는 의미이며 이런 연산자들을 자유자재로 사용할 수 있다면 복잡한 연산을 간단하게 처리할 수 있습니다. 우선 기본적으로 4칙 연산을 제공하는 산술 연산자가 있습니다.

```C++
x + y // x와 y를 더한다.
x - y // x에서 y를 뺀다.
x * y // x와 y를 곱한다.
x / y // x를 y를 나눈다.
x % y // x를 y로 나눈 나머지.

result = x + y; // x + y의 값을 result에 저장한다.
```

여기서 정수, 정수를 계산하면 결과는 늘 정수가 됩니다. 예를 들어 (5 / 2)를 하게 되면 그 값은 2.5일 것입니다. 그러나 C++에서는 정수 / 정수이므로 그 값은 정수가 되어 2라는 값이 될 것입니다. 하지만 피연산자 중 하나만 실수라면 계산 결과는 실수가 되어 2.5라는 값이 될 것입니다. 이러한 특징을 살려서 다음과 같이 나타낼 수도 있습니다.  

```C++
int x = 5, y = 2;
int resultI = 0;
double resultD = 0.0f;

resultI = x / y; // 2를 저장
resultD = (double)x / y; // 2.5를 저장
```

++, -- 연산자 또한 존재합니다. 이는 그 변수에 저장된 값에 +1, -1을 하라는 의미인데 이 연산자가 변수의 어디에 붙느냐에 따라 그 의미가 달라질 수 있습니다.

```C++
int i = 10;

i++; // i = 11
i--; // i = 10

++i; // i = 11
--i; // i = 10
```

위의 코드를 보게 되면 ++, --가 변수의 앞에 붙든 뒤에 붙든 다 똑같은 결과를 내는거 아닌가? 뭐가 다르다는거지라고 생각하실 수 있습니다. 다른 예시를 보여드리겠습니다.  

```C++
int i = 10;
int result = 0;

// result += i++ 는 result = result + i++와 의미가 같습니다.
result += i++; // result = 10
result += ++i; // result = 22
```

차이가 보이시나요? 첫번째 줄인 result += i++에서는 result = result + i가 먼저 실행 된 후에 i에 +1이 더해졌고 두번째 줄인 result += ++i에서는 i 에 +1이 더해진 후에 result = result + i가 실행되었습니다. 즉, i에 +1을 이 명령어가 끝난 뒤에 할 지 아니면 이 명령어 시작 전에 할 지 차이를 두게 되는 것입니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*

