---
layout: single
title:  "C++_STL과_람다식"
categories: study
tags: [c++]
---

# STL과 람다식
이번에는 STL과 람다식에 대해 학습하겠습니다. STL은 많은 프로그래머들이 공통적으로 사용하는 자료 구조와 알고리즘을 구현한 클래스들로 이루어져서 이러한 자료 구조나 알고리즘을 직접 구현하지 않고 편하게 가져다 사용할 수 있다는 장점이 있습니다. 람다식은 이름이 없는 함수라고 생각하시면 됩니다. 간결함 때문에 이를 사용하는데 이 둘에 대해서 자세히 학습해보겠습니다.  

#### **STL**
STL은 표준 템플릿 라이브러리(Standard Template Library)의 약자로 자료 구조와 알고리즘을 구현한 클래스들로 이루어져 있습니다. STL은 템플릿 기법을 사용하였기에 어떤 자료형에도 대응할 수 있고 프로그래머가 직접 객체를 생성하지 않으면 코드 길이에 포함되지 않는 장점이 있습니다.  

STL은 3가지 종류의 컴포넌트(컨테이너, 반복자, 알고리즘)를 제공합니다.  

**컨테이너**  
컨테이너는 자료를 저장하는 창고와 같은 역할을 하는 구조입니다. 즉, 배열이나 연결 리스트, 벡터, 집합, 사전, 트리 등이 여기에 해당합니다. 컨테이너는 최대한 일반화 기법을 사용하여 작성되었기에 어떤 자료형도 저장할 수 있습니다.  

**반복자**  
반복자(iterator)는 컨테이너의 요소를 가리키는 데 사용됩니다. 반복자는 실제로 컨테이너와 알고리즘 사이의 다리 역할을 합니다. 반복자를 사용하면 컨테이너의 유형에 상관없이 동일한 알고리즘을 적용시킬 수 있다는 장점이 있습니다.  

**알고리즘**  
새로운 프로그램을 작성할 때 상당히 많은 알고리즘들이 필요합니다. 예를 들면 게임 프로그램에서 사용자가 가진 아이템들을 정렬해서 보여주는 기능이 필요할 수 있습니다. 많은 자료 중에서 특별한 자료를 찾아야한다던지, 자료를 정렬할 때 특정 기준을 준다던지, 자료의 순서를 뒤집어버린다던지 하는 많은 알고리즘들이 필요할 수 있는데 이들을 하나하나 작성하기보다는 누군가 작성해놓은 오류 없는 버전을 사용하는 편이 빠르고 간편합니다.  

STL은 위의 이유들로 컨테이너와 함께 사용되는 많은 알고리즘들을 작성하여서 제공합니다. 간단하게 알고리즘들이 무엇이 있는지만 보겠습니다. 자세한건 뒤에서 설명드리겠습니다.  

- 탐색(find): 컨테이너 안에서 특정한 자료를 찾는다.
- 정렬(sort): 자료들을 크기 순으로 정렬한다.
- 반전(reverse): 자료들의 순서를 역순으로 한다.
- 삭제(remove): 조건이 만족되는 자료를 삭제한다.
- 변환(transform): 컨테이너의 요소들을 사용자가 제공하는 변환 함수에 따라서 변환한다.

**STL 사용의 장점**  
3가지의 장점을 들 수 있습니다.  

1. STL은 프로그래밍에 매우 유용한 수많은 컨테이너와 알고리즘을 제공합니다. 그렇기에 개발자는 이러한 컨테이너와 알고리즘 개발에 시간과 노력을 절약할 수 있습니다.  

2. STL은 객체 지향 기법과 일반화 프로그래밍 기법을 적용하여서 만들어졌으므로 어떤 자료형에 대해서도 사용할 수 있습니다. 즉, 자료형마다 특정 알고리즘을 구현할 필요가 없습니다.  

3. STL은 전문가가 만들어서 테스트를 거친 검증된 라이브러리로 버그를 발생시키지 않기에 안심하고 사용할 수 있습니다. 또한 표준 라이브러리이기에 어떤 C++ 컴파일러도 지원하여 호환성 문제를 일으키지 않습니다.  

#### **컨테이너**
앞에서 간략하게 소개했던 컨테이너에 대해 자세히 알아봅시다. STL의 컨테이너 라이브러리는 컨테이너를 제공합니다. 컨테이너는 데이터들을 저장하는 클래스라고 할 수 있습니다. 컨테이너는 배열, 리스트, 트리, 연관 배열 등과 같이 복잡한 데이터 구조를 쉽게 구현하는데 도움을 줍니다. 컨테이너는 템플릿으로 구현되므로 컨테이너가 서로 다른 종류의 객체를 저장하는데 사용될 수 있습니다. 다음은 몇 가지 일반적인 컨테이너입니다.  

- 벡터(vector): 동적 배열처럼 동작한다. 뒤에서 자료들이 추가된다.
- 큐(queue): 데이터가 입력된 순서대로 출력되는 자료 구조
- 스택(stack): 먼저 입력된 데이터가 나중에 출력되는 자료 구조
- 우선 순위큐(priority queue): 큐의 일종으로 큐의 요소들이 우선 순위를 가지고 있고 우선 순위가 높은 요소가 먼저 출력되는 자료 구조
- 리스트(list): 벡터와 유사하지만 중간에서 자료를 추가하는 연산이 효율적이다.
- 집합(set): 중복이 없는 자료들이 정렬되어서 저장
- Map: 키-값(key-value)의 형식으로 저장. 키가 제시되면 해당되는 값을 찾을 수 있다.

**컨테이너의 분류**  
- 순차 컨테이너: 순차 컨테이너는 이름 그래도 자료를 순차적으로 가집니다. 대표적으로 벡터와 리스트(list)를 들 수 있으며 순차적인 컨테이너는 자료의 추가가 빠르지만 탐색 시 시간이 많이 걸리게 됩니다.  

- 연관 컨테이너: 연관 컨테이너는 사전과 같은 구조를 사용하여서 자료를 저장합니다. 연관 컨테이너는 원소들을 검색하기 위한 키(key)를 가집니다. 자료들은 정렬되어 있으며 자료의 추가에는 시간이 걸리지만 자료의 탐색이 매우 빠릅니다. Map이나 집합이 대표적인 연관 컨테이너입니다.  

#### **반복자**
이번에는 반복자에 대해 자세히 알아보겠습니다. 컨테이너와 알고리즘을 제대로 사용하려면 반복자(iterator)를 올바르게 이해하여야 합니다. 컨테이너에는 요소들이 저장되어 있습니다. 각 요소들에 접근하려면 어떻게 해야할까요?  

예전의 방법들을 먼저 생각해보겠습니다. 배열과 비슷한 벡터에서는 인덱스를 이용하여 요소에 접근할 수 있습니다. 그러나 랜덤 접근을 허용하지 않는 연결 리스트에서는 인덱스는 사용할 수 없고 아마 포인터를 사용하여야 할 것입니다. 문제는 컨테이너의 종류에 따라서 요소에 접근하는 방법이 상당히 다르다는 점입니다. 그렇기에 일반적인 방법이 필요합니다.  

STL을 작성한 사람들은 컨테이너의 종류에 관계없이 요소들에 접근하게 하기 위하여 반복자라는 방식을 제안하였습니다. 반복자는 컨테이너의 요소를 가리키는 객체입니다. 기존의 포인터와 비슷하여서 반복자를 흔히 일반화된 포인터(generalized pointer)라고 합니다. 반복자를 사용하게 되면 컨테이너의 종류에 상관없이 일관된 방법으로 컨테이너의 요소 접근이 가능해집니다.  

반복자는 어디에 이용될까요? 알고리즘은 컨테이너의 요소에 접근하여서 읽거나 써야 합니다. 이때에 반복자가 사용되게 되는 것입니다. 반복자를 사용하여서 컨테이너의 첫 번째 요소를 가리키게 한 후에 작업을 하고 작업이 끝나면 반복자를 증가하여서 다음 요소를 가리키게 합니다. 반복자가 마지막 요소를 벗어나게 되면 작업을 끝내면 됩니다.  

STL의 핵심 개념은 시퀀스(sequence)입니다. 시퀀스는 어떤 순서를 가지고 있는 일련의 데이터입니다. 시퀀스에는 시작과 끝이 있습니다. 시퀀스는 처음부터 끝까지 순회 가능하며 중간 요소 읽기 또는 쓰기가 가능합니다. 반복자는 시퀀스의 요소를 식별하는 객체입니다. 예를 들어 begin()과 end()는 반복자로서 시퀀스의 시작과 끝을 식별합니다.  

begin()은 시퀀스의 첫 번째 요소를 end()는 시퀀스의 끝을 하나 지난 위치를 가리킵니다.  

반복자에서는 다음과 같은 연산자들을 사용할 수 있습니다. 반복자는 연산자가 중복 정의되어 있는 객체라고 생각하면 됩니다.  
- ++ 연산자: 다음 요소를 가리킨다.
- -- 연산자: 이전 요소를 가리킨다.
- ==, != 연산자: 두 반복자가 같은 요소를 가리키는 지를 확인한다.
- \* 연산자: 반복자가 가리키는 요소의 값을 추출한다.

자 그러면 반복자를 사용한 예시를 보이겠습니다.  

```C++
vector<int> vec;
vector<int>::iterator it;

for(it = vec.begin(); it != vec.enc(); it++){
    cout << *it << " ";
}
```

위의 코드를 보면 it가 바로 반복자임을 알 수 있으실 것입니다. 반복문은 vec의 요소를 처음부터 끝까지 돌면서 그 값들을 출력하는 것입니다. 최근 버전에서는 auto 키워드와 범위 기반 루프를 사용하여 훨씬 간단하게 작성이 가능합니다.  

```C++
vector<int> vec;
auto it;

for(it = vec.begin(); it != vec.end(); it++){
    cout << *it << " ";
}

// 혹은 아래처럼 작성도 가능

vector<int> v;

for(auto& n : v){
    cout << n << endl;
}
```

반복자는 코드(알고리즘)을 데이터에 연결하는 데 사용됩니다. 코드 작성자는 반복자에 대해 알고 있지만 반복자가 실제로 데이터에 어떻게 접근하는지에 대해서는 자세히 알지 않으며 데이터 공급자는 데이터가 저장되는 방식에 대한 세부 정보를 표시하지 않고 단순히 사용자에게 반복자를 제공합니다. 따라서 반복자는 알고리즘과 컨테이너 사이의 독립성을 제공합니다.  

**반복자의 종류**  
반복자에는 3가지의 종류가 있습니다.  
- 전향 반복자(forward iterator): ++ 연산자만 가능
- 양방향 반복자(bidirectional iterator): ++ 연산자와 -- 연산자가 가능
- 무작위 접근 반복자(random access iterator): ++ 연산자와 -- 연산자, [] 연산자가 가능

#### **컨테이너의 공통 멤버 함수**
컨테이너는 데이터들을 저장하는 클래스라고 할 수 있습니다. 여기서는 모든 컨테이너가 공통으로 지원하는 멤버 함수들을 살펴보겠습니다. 이 함수들은 어떤 컨테이너에 대해서도 사용할 수 있습니다.  

```
- Container(): 기본 생성자
- Container(size): 크기가 size인 컨테이너 생성
- Container(size, value): 크기가 size이고 초기값이 value인 컨테이너 생성
- Container(iterator, iterator): 다른 컨테이너로부터 초기값의 범위를 받아서 생성
- begin(): 첫 번째 요소의 반복자 위치
- clear(): 모든 요소 삭제
- empty(): 비어있는지 검사
- end(): 반복자가 마지막 요소를 지난 위치
- erase(iterator): 중간 요소 삭제 후 다음 요소의 위치를 반환
- erase(iterator, iterator): 지정된 범위 요소 삭제 후 다음 요소의 위치를 반환
- front(): 첫 번째 요소 반환
- insert(iterator, value): 중간에 value를 삽입
- pop_back(): 마지막 요소를 삭제
- push_back(value): 끝에 value 추가
- rbegin(): 끝을 나타내는 역반복자
- rend(): 역반복자가 처음을 지난 위치
- size(): 컨테이너의 크기
- operator=(Container): 대입 연산자의 중복 정의
```

#### **덱**
덱(deque)은 'double-ended queue'의 약자로 양방향으로 커질 수 있도록 구현된 동적 배열입니다. 덱과 벡터가 다른 점은 덱의 경우, 전단과 후단에서 모두 요소를 추가하고 삭제하는 것을 허용한다는 점입니다. 덱의 끝과 시작 부분에 요소를 추가하는 것이 빠릅니다. 하지만 중간에 요소를 추가하려면 요소를 이동해야 하므로 시간이 걸리게 됩니다.  

#### **리스트**
리스트(list)는 외부에서 보면 벡터와 완전히 동일합니다. 벡터와 마찬가지로 순차적으로 데이터를 저장하기에 벡터를 리스트로 대체하는 것도 가능합니다. 하지만 이 둘은 내부 구조에 차이를 가집니다. 리스트 컨테이너는 이중 연결 리스트로 구현됩니다. 이중 연결 리스트는 중간 위치에서 삽입이나 삭제가 빈번한 경우에 효율적인 자료 구조입니다. 이중 연결 리스트에서는 모든 노드가 앞 노드와 뒤 노드를 가리키는 포인터를 동시에 가지기에 반복자를 이용하여서 양방향 이동이 가능합니다.  

만약 삽입이나 삭제가 양 끝단에서만 빈번하게 발생한다면 덱(deque)을 사용하는 것이 유리할 것입니다. list 클래스는 공통 멤버 함수 말고도 추가로 다음과 같은 함수들을 가집니다. push_front(), pop_front(), remove(), unique(), merge(), revers(), sort(), splice() 등을 가집니다.  

**벡터와 리스트의 차이점**  
- 벡터에서는 임의 접근이 가능하지만 리스트에서는 불가능합니다. 리스트는 [] 연산자를 지원하지 않으며 리스트에서 어떤 요소에 접근하려면 첫 번째 요소부터 순차적으로 이동하여야 합니다. 따라서 임의 접근 반복자를 필요로 하는 binary_search()같은 알고리즘 사용이 불가합니다.  
- 벡터에서는 중간 위치에 삽입이나 삭제를 하려면 뒤의 요소들을 이동하여야 하므로 시간이 오래 걸립니다. 반면 리스트에서는 앞 노드의 링크만 조작하면 되므로 매우 효율적으로 삽입, 삭제가 가능합니다.  
- 리스트에서는 각 데이터마다 링크를 저장하여야 하기에 기억 공간을 더 많이 차지합니다.  

#### **집합**
앞의 벡터나 리스트는 자료 사이에 순서가 존재합니다. 만약 순서에 상관없이 자료만 저장하고 싶다면 어떨까요? 이때 사용할 수 있는 구조가 집합(set)과 다중 집합(multi-set)입니다. 집합에 저장된 자료를 키(key)라고 합니다. 집합은 동일한 키를 중복해서 가질 수 없기에 중복된 값은 저장하지 않으면서 들어오는 값들은 정렬된다는 특징을 가집니다. 다중 집합은 중복을 허용한다는 차이가 있습니다.  

#### **Map**
Map은 많은 데이터 중에서 원하는 데이터를 빠르게 찾을 수 사전과 같은 자료 구조입니다. 사전처럼 단어(키(key))가 있고 이것에 대한 설명(값(value))이 있습니다. Map은 중복되 키를 가질 수 없으며 각 키는 오직 하나의 값에만 매핑될 수 있습니다. 키가 제시되면 Map은 값을 반환합니다.  

Map도 상당히 자주 사용되는 중요한 자료 구조입니다. Map의 객체를 생성하기 위해서는 두 가지의 타입을 명시하여야 합니다. 하나는 키(key)를 위한 타입이고 또 하나는 값(value)을 위한 타입입니다. Map의 장점은 탐색을 쉽게 할 수 있다는 점입니다.  

Map에 데이터를 저장하는 방법은 여러 가지로 insert()를 사용하여도 되지만 [] 연산자 안에 키를 넣고 값을 대입하는 것이 제일 간편합니다. 어떤 자료를 찾을 때도 [] 연산자를 사용하는 것이 제일 쉽습니다. 물론 find()도 가능합니다.  

#### **컨테이너 어댑터**
컨테이너 어댑터(container adapter) 클래스는 이미 존재하는 컨테이너를 변경하여서 새로운 기능을 제공하는 클래스입니다. 즉, 기존의 컨테이너의 기능을 그대로 이용하면서 새로운 기능이나 인터페이스를 제공하는 것입니다. 컨테이너 어댑터에는 스택, 큐, 우선 순위 큐 등이 있습니다.  

**스택**  
스택은 늦게 들어온 데이터들이 먼저 나가는 기능을 가지는 자료형입니다 이것을 후입 선출(LIFO: last-in first-out)이라고 합니다. 스택은 컴퓨터에서 아주 중요한 자료 구조로 함수 호출이 스택을 사용하여 이루어집니다. 함수가 호출되고 복귀할 때 바로 스택에 저장된 순서대로 복귀하는 것입니다.  

스택을 구현하기 위해서는 선형적인 자료 구조만 있으면 됩니다. 즉, 배열이나 연결 리스트를 이용하여서 스택을 작성 가능합니다. 스택에서는 중간에서 데이터를 추가하거나 삭제하는 기능은 필요 없기에 순차 컨테이너를 이용하여 쉽게 만들 수 있는 것입니다.  

스택에서는 다음과 같은 함수들이 제공됩니다. 이 중 가장 중요한 연산은 push()와 pop()입니다.  
- push(value): value 삽입
- pop(): 스택 상단 원소 삭제
- top(): 상단 원소 반환
- empty(): 공백이면 true 반환
- size(): 원소 개수 반환

**큐**  
큐(queue)는 먼저 들어온 데이터들이 먼저 나가는 자료 구조입니다. 이것을 선입 선출(FIFO: first-in first-out)이라고 합니다. 주로 큐는 데이터를 처리하기 전에 잠시 저장하고 있는 용도로 사용됩니다. 큐도 스택과 마찬가지로 중간에서 데이터를 추가하거나 삭제할 수 없습니다.  

큐에서는 다음과 같은 함수들이 제공됩니다.  
- push(value): value 삽입
- pop(): 첫 번째 원소 삭제
- front(): 첫 번째 원소 반환
- back(): 마지막 원소 반환
- empty(): 공백이면 true 반환
- size(): 원소 개수 반환

**우선 순위 큐**  
우선 순위 큐는 큐와 아주 비슷하지만 원소들이 우선 순위를 가진다는 특징이 있습니다. 원소들은 들어온 순서와 상관없이 우선 순위가 높은 원소가 먼저 나가게 됩니다. 우선 순위 큐는 히프(heap)라고 하는 자료 구조를 내부적으로 사용합니다. 

#### **STL 알고리즘**
탐색(searching), 정렬(sorting), 개수세기(counting)과 같은 일반적인 알고리즘은 프로그램에서 널리 사용됩니다. STL은 이러한 문제들을 해결하기 위해 템플릿 기반의 함수들을 제공합니다. 이들 알고리즘은 거의 모든 컨테이너에 대하여 같은 방식으로 동작합니다. 템플릿을 사용하여서 일반화 프로그래밍을 적용하고 있는 것입니다.  

STL 알고리즘은 일반적으로 반복자를 사용하여 주어진 타입으로 생성된 컨테이너에 접근합니다. 반복자는 알고리즘과 컨테이너를 연결하는 역할을 하는데 이 라이브러리를 사용하는 코드는 프로그래머가 직접 작성한 코드와 비교하여도 효율성에 있어서 손색이 없습니다. 이들 알고리즘을 사용하려면 <algorithm> 헤더 파일을 포함하면 됩니다.  

STL 알고리즘은 너무 많기에 가장 많이 사용되는 알고리즘 위주로 보도록 하겠습니다. 알고리즘은 크게 컨테이너가 변경되는 변경 알고리즘과 그렇지 않은 불변경 알고리즘으로 나뉩니다.  

*불변경 알고리즘*
- count(): 주어진 값과 일치하는 요소들의 개수를 센다
- count-if(): 주어진 조건에 맞는 요소들의 개수를 센다.
- search(): 주어진 값과 일치하는 첫 번째 요소 반환
- search_n(): 주어진 값과 일치하는 n 개의 요소 반환
- find(): 주어진 값과 일치하는 첫 번째 요소 반환
- find_if(): 주어진 조건에 일치하는 첫 번째 요소 반환
- find_end(): 주어진 조건에 일치하는 마지막 요소 반환
- binary_search(): 정렬된 컨테이너에 대하여 이진 탐색 수행
- equal(): 두 개의 요소가 같은지 비교
- mismatch(): 두 개의 컨테이너를 비교하여서 일치하지 않는 첫 번째 요소 반환
- lexicographical_compare(): 두 개의 순차 컨테이너를 비교하여서 사전적으로 어떤 컨테이너가 작은지를 반환

*변경 알고리즘*
- fill(): 지정된 범위의 모든 요소를 지정된 값으로 채운다.
- generate(): 지정된 함수의 반환값을 할당
- for_each(): 지정된 범위의 모든 요소에 대해 연산 수행
- transform(): 지정된 범위의 모든 요소에 대해 함수 적용
- copy(): 하나의 구간을 다른 구간으로 복사
- remove(): 지정된 구간에서 지정된 값을 가지는 요소 삭제
- unique(): 중복된 요소는 한 개를 제외하고 뒤로 옮긴 후 중복된 요소 시작 위치 반환
- replace(): 지정된 구간에서 요소가 지정된 값과 일치하면 대치값으로 바꾼다.
- sort(): 지정된 정렬 기준에 따라서 구간의 요소들 정렬
- partition(): 지정된 구간의 요소들을 조건에 따라 두 개의 집합으로 나눔

#### **람다식**
람다식(lambda expression)은 나중에 실행될 목적으로 다른 곳에 전달될 수 있는 함수 객체입니다. 람다식은 이름 없는 함수라고 할 수 있습니다. 람다식은 간결함 때문에 사용되며 이를 이용하면 함수가 필요한 곳에 간단히 함수를 보낼 수 있습니다. 특히 함수가 딱 한번만 사용되고 함수의 길이가 짧은 경우 유용합니다.  

다음은 람다식 작성 방법입니다.  

```C++
[] (arg1, arg2, ...) 반환형 { body }
```

간단하게 매개 변수 x와 y를 전달받아서 x + y를 반환하는 함수를 람다식으로 작성해보겠습니다.  

```C++
auto sum = [](int x, int y){ return x + y; }

sum(1, 2) // 3
```

람다식을 사용하면 함수를 사용하려는 장소에서 바로 함수를 작성할 수 있습니다. 함수가 딱 한 번만 사용되고 메서드 정의가 짧을 경우 유용합니다. 클래스 안에서 별도의 함수를 선언하고 작성하는 수고를 덜어주는 것입니다.  

람다식은 STL 알고리즘에서 많이 사용됩니다. 예를 들어 count_if()를 사용하는 경우를 보겠습니다.  

```C++
auto count = count_if(numbers.begin(), numbers.end(), [](int x) {return (x > 5)})
```

위처럼 작성하게 되면 numbers 컨테이너에서 5보다 큰 수인 요소는 몇 개인지 반환하게 되는 것입니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  

*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*
