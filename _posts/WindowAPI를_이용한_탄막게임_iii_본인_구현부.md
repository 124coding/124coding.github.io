---
layout: single
title:  "WindowAPI를_이용한_탄막게임_iii_본인_구현부"
categories: development
---

## 이제부터는 수업 중이 아닌 제가 직접 구현한 부분들에 대해서 설명하도록 하겠습니다.

# 다양한 탄환 클래스화
제가 만든 다양한 탄환들에 대해서 설명하겠습니다.  
먼저 기본탄환으로 발사 시 일직선으로 나가는 역할만을 수행합니다. 플레이어의 탄환과 적의 기본 공격이 이에 해당합니다.  
두번째로 유도탄으로 기본적으로 적이 사용하기에 플레이어를 쫓아옵니다.  
세번째로 경로를 따라가는 경로탄입니다. 특정 경로의 포인트들을 순서대로 큐에 넣어 그 순서를 따라가게 합니다.  

# 탄환들에 따른 적 패턴 구현
위에 탄환들에 맞춰서 적의 다양한 패턴을 구현하였습니다.  
1. 적이 중앙으로 와서 360도로 총알을 발사
2. 적이 순간이동하면서 유도탄을 난사
3. 적이 한 쪽 끝으로 이동했다가 다른 쪽으로 쭉 이동하면서 유도탄과 기본 탄환을 발사
4. sin파와 cos파에 영감을 받아 그런 파형으로 경로탄 발사
5. 기본 상태에서 발사하는 패턴으로 8방향 탄환 발사, 중간중간 경로탄, 유도탄을 발사

# 게임 플레이와 게임 오버
기본적으로 프로그램이 시작이 되면 바로 게임이 들어가게 되고 그 후 적의 체력을 다 깍거나 본인의 체력이 다 깍이는 2가지의 경우에 대해 각각 게임 오버와 게임 승리에 대한 상태로 설정하게 하였습니다. 이것은 FSM이라는 개념으로 이에 대한 더 자세한 설명은 뒤에 하도록 하겠습니다.  

# 플레이어의 이동 보완
먼저 작성된 이동에 대한 코드는 이동에 대한 키 입력을 받을때 현재 속도에 키 입력 시 속도를 덮어씌우는 방식이기 때문에 대각선 이동 등이 구현이 안되는 문제가 있었는데 제가 보완한 코드에서는 변수를 이용하여 키가 눌려있는지 확인하고 그것에 맞게 속도를 더하는 식으로 하여 더 다양한 행동이 가능하게 하였습니다.  

# 사용된 기술들
## 충돌 관련
충돌에 사용된 기술들에 대해서 설명드리겠습니다. 수업때 들은 내용에서의 충돌은 간단한 구현을 위해 따로 패턴을 쓴게 아닌 그저 적과 플레이어의 탄환과의 충돌만을 계산하였었습니다.  

저는 충돌을 구현할때 다양한 객체 각각의 충돌에 대해서 구현이 필요할 것이라고 생각하였고 이것에 대해 따로 알아보는 중에 충돌 그룹과 더블 패치에 대한 개념에 대해 알게 되었습니다.  

먼저 **충돌 그룹**에 대해서 설명하겠습니다. 각 객체들의 충돌을 설정할때 하나의 객체 개별개별마다 충돌을 다 지정해주면 코드가 엄청 복잡해지고 후에 유지보수도 어려워질 것입니다. 그렇기에 충돌 그룹이라는 개념은 꼭 필요하게 되는데 충돌 그룹은 클래스마다 어떤 클래스와 충돌이 가능하게 할 것인지에 대해서 미리 설정을 해놓는 것입니다.  

예를 들면,  
적, 플레이어, 총알 이렇게 3개의 클래스가 존재할 때 적, 플레이어, 총알은 충돌이 가능하고 적의 총알은 플레이어와 플레이어의 총알은 적과 충돌이 가능합니다. 이러한 충돌들을 위해 enum class로 각 그룹을 지정해주고 각 그룹에 맞게 충돌을 설정해주는 것입니다.  

이때 **enum class**란 기존 enum(열거형)의 단점을 보완하여 타입 안전성을 강화한 사용자 정의 타입입니다.

사용하는 예시를 보게 되면 (enum과 enum class의 차이)
```C++
// 기존 enum (이름 충돌 발생)
enum Color { RED, GREEN, BLUE };
enum TrafficLight { RED, YELLOW, GREEN }; // 컴파일 오류: RED와 GREEN이 중복 정의됨

// enum class (스코프가 분리되어 문제 없음)
enum class Color { RED, GREEN, BLUE };
enum class TrafficLight { RED, YELLOW, GREEN };
```

제 프로그램에서 사용하는 예시로 보게 되면
```C++
enum class CollisionGroup {
	Actor,
	Enemy,
	Actor_Bullet,
	Enemy_Bullet
};

// Actor 클래스에서
if (tBullet->GetCollisionGroup() == CollisionGroup::Enemy_Bullet) {};
```
다음과 같이 사용할 수 있습니다.  

이제 **더블 패치**에 대해서 설명드리겠습니다.  
더블 패치에 대해서 간단하게 설명드리면 먼저 부모 클래스에 첫번째 패치를 놓고 자식 클래스에 그에 맞는 두번째 패치를 두게 됩니다. 예시를 먼저 보여드리면

```C++
// 부모 클래스 (순수 가상 함수로 작성)
virtual void CollideWith(CUnit* tOther) = 0; // 첫 번째 디스패치
virtual void Accept(CActor* tActor) = 0;
virtual void Accept(CEnemy* tEnemy) = 0;
virtual void Accept(CBullet* tBullet) = 0;

// 자식 클래스
void CollideWith(CUnit* tOther) override {
	tOther->Accept(this); // 두 번째 디스패치
}
void Accept(CActor* tActor) override {};
void Accept(CEnemy* tEnemy) override {};
void Accept(CBullet* tBullet) override {};
```

부모 클래스에 다음과 같이 순수 가상 함수로 첫번째 패치와 그에 사용될 Accept 함수들을 작성하여서 자식 클래스들에서 override하여 사용할 수 있게 해야 합니다.  

이제 게임의 Update마다 각 클래스마다 충돌에 관하여 확인하고 충돌이 발생했다면 어떤 클래스와 충돌이 발생했냐에 따라 그 클래스에 맞는 충돌 함수를 디스패치를 통해 알맞게 부를 수 있게 되는 것입니다.   

## 화면 전환
화면 전환을 알기 전에 **FSM(유한 상태 기계)**라는 개념에 대해 먼저 설명하겠습니다. 이는 시스템이 가질 수 있는 유한한 수의 '상태'와 그 상태들 사이의 '전환'을 정의하여 복잡한 동작을 단순하게 표현하는데 사용됩니다. 즉, FSM은 정해진 규칙에 따라 한 번에 하나의 상태에만 머물게 하는 기계라고 생각할 수 있습니다.  

FSM은 크게 세 가지 요소로 구성됩니다.  
1. 상태(State): 시스템이 현재 머무르고 있는 특정 상황이나 조건
2. 전환(Transition): 하나의 상태에서 다른 상태로 바뀌는 과정으로 전환은 특정 입력이나 조건이 충족되면 일어나게 됩니다.  
3. 입력(Input): 상태 전환을 일으키는 원인이나 사건을 의미

이러한 FSM을 이용하여 화면 전환을 쉽게 이룰 수 있게 됩니다.  
이제 제 프로그램을 예시로 하여 보여드리겠습니다.  

먼저 제 프로그램에는 3개의 상태가 존재하게 하였습니다.  
1. 게임 플레이 중
2. 게임 승
3. 게임 오버(플레이어가 짐)

그렇다면 각 화면의 전환은 어떻게 이뤄질까요?
1. 게임 시작 (바로 게임 플레이)
2. 플레이어의 체력이 0이 됨.
3. 게임 오버로 전환
4. R키를 누르면 다시 게임 플레이로 전환
5. 적의 체력이 0이 됨.
6. 게임 승으로 전환

제 프로그램에서는 다음과 같은 과정을 따르게 합니다. 물론 플레이어와 적 중에서 체력이 먼저 0이 되는 경우에 따라 게임 승과 게임 오버 상태가 불리게 되는 것입니다.  

이렇게 게임을 하는 중에 상태가 오직 한 개만 정의되기에 오류를 범할 일도 없게 됩니다.  

## Template 함수
일단 **Template 함수**가 무엇인지 먼저 설명드리겠습니다.  
템플릿 함수는 함수의 틀 또는 설계도와 같습니다. 특정 자료형에 얽매이지 않고, 다양한 자료형에 대해 동일한 로직을 수행하는 함수를 한 번만 정의할 수 있게 해줍니다. 쉽게 말하자면 자료형을 함수의 매개변수(parameter)처럼 다룰 수 있게 해주는 것입니다.  

예시를 보이자면,
```C++
template <typename T>
T add(T a, T b) {
    return a + b;
}

cout << add<int>(3, 5) << endl; // 8
cout << add<float>(1.5, 2.3) << endl; // 3.8
```

제 프로그램에서는 충돌을 관리할때 사용하였습니다. 함수를 부를때 부모클래스로 업캐스팅하여 사용하기에 굳이 Template으로 하지 않아도 문제 없을것처럼 보이지만 혹시 모를 다음의 업데이트에서 필요할 것 같다고 판단하여 사용하였습니다.  

### 더 다양하게 사용된 기술들이 많지만 중요하게 사용되었다고 생각하는 기술들은 다음과 같아서 여기까지만 작성하도록 하겠습니다.  
### 제가 개인적으로 공부하면서 작성하는 내용이라 오류를 범하는 부분이 있을 수도 있습니다.