---
layout: single
title:  "C++_다형성과_가상_함수"
categories: study
tags: [c++]
---

# 다형성과 가상 함수
이번에는 다형성과 가상 함수에 대해서 설명하겠습니다. 다형성은 앞 전에도 몇번 언급한 적이 있었습니다. 가상 함수는 virtual 키워드를 이용하는 함수로 자세히 학습해보겠습니다.  

#### **다형성**
객체 지향에서 다형성(polymorphism)이란 하나의 기호를 여러 가지 의미로 사용하는 기술입니다. 함수 중복 정의나 연산자 중복 정의도 이에 해당하는 것입니다. 이번에는 실행 시간 다형성에 대해 학습하겠습니다. 이는 가상 함수를 이용하는 방법입니다.  

"실행 시간 다형성"이란 객체들의 타입이 다르면 똑같은 메시지가 전달되더라도 서로 다른 동작을 하는 것을 말합니다. 이는 다양한 객체에게 같은 함수를 호출하라고 명령을 보내더라도 서로 정의되어 있는 해당 함수에 대한 내용이 다르니 각각 다른 행동을 보이는 것을 말하는 것입니다.  

여기서 중요한 부분은 메시지를 보내는 측이 객체가 어떤 타입인지 알 필요가 없다는 것입니다. 실행 시간에 객체의 타입에 따라서 자동적으로 적합한 동작이 결정됩니다. 이렇듯 다형성은 객체 기향 기법의 특징 중 하나로 동일한 코드로 다양한 타입의 객체를 처리하는 기술입니다.  

**상향 형변환**  
다형성은 객체 포인터를 통하여 이루어집니다. 객체 포인터는 객체를 가리키는 포인터로 설명을 위해 Animal 클래스와 이를 상속받는 Cat, Dog 클래스가 있다고 하고 설명을 이어가겠습니다. 객체 포인터도 타입이 맞는 객체만을 가리킬 수 있습니다. 즉 Dog 객체의 포인터는 Dog 타입의 객체만을 가리킬 수 있습니다. 그러나 다음과 같다면 어떨까요?

```C++
Animal* pa = new Dog();
```
위의 문장은 Animal 타입의 포인터로 Dog 타입의 객체를 가리키는 문장입니다. 이는 문제가 없을까요? 놀랍게도 아무 문제가 없음을 확인하실 수 있으실 겁니다. 그렇다면 왜 문제가 없을까요?  

왜냐하면 자식 객체는 부모 객체를 포함하기 때문입니다. 이는 자식 객체는 부모 객체이기도 하다는 뜻입니다. 따라서 부모 포인터로 자식 객체를 가리킬 수 있게 되는 것입니다. 이는 다형성의 핵심이 됩니다.  

이러한 포인터 타입의 변환을 상향 형변환(up-casting)이라고 합니다. 아래에서 위 즉, 객체 포인터가 상속 계층도에서 부모 클래스 쪽을 가리킨다는 의미입니다. 상향 형변환을 하면 자식 클래스 중에서 부모 클래스로부터 상속받은 부분만을 포인터를 통해서 사용할 수 있고 나머지 부분은 사용할 수 없게 됩니다. 위의 코드를 예로 들자면 pa를 이용하여 상속 받은 Animal의 멤버 부분들은 사용할 수 있지만 그렇지 않고 새로 작성된 Dog의 멤버는 사용할 수 없다는 것입니다.  

만약 Dog에서 Animal에 있던 speak이라는 함수를 재정의하여 사용하여서 speak을 불러서 사용한다고 해도 결국 Animal에 있는 speak 함수가 사용될 것입니다. 그렇다면 이러한 상향 형변환은 왜 사용되는 것일까요? 오류가 없다는건 알겠는데 정말 쓸모가 없어보입니다.  

**가상 함수**  
그렇다면 Animal 포인터를 통하여 객체의 멤버 함수를 호출하더라도 객체의 종류에 따라 서로 다른 speak 함수를 호출한다면 어떨까요? 이는 굉장히 유용하게 사용될 수 있을 것 같습니다. 즉, Dog인 경우는 "멍멍", Cat인 경우는 "야옹"과 같이 분명 Animal 포인터이지만 객체의 종류에 따라 호출되는 함수의 행동이 다른 것입니다. 이렇게 된다면 다양한 자식 클래스의 객체들에 대해서 공통된 기능을 따로따로 실행시키는 것보다 일관되게 처리하는 것이 가능할 것입니다. 이것을 위해 C++에서는 가상 함수(virtual function)가 준비되어 있습니다.  

가상 함수는 virtual 키워드를 이용하여 정의합니다.

```C++
class Animal{
public:
    virtual void speak() { cout << "동물 소리" << endl; }
};

class Dog{
public:
    void speak() { cout << "멍멍" << endl; }
};

class Cat{
public:
    void speak() { cout << "야옹" << endl; }
};

int main(){
    Animal *a1 = new Dog();
    a1->speak(); // 멍멍 출력

    Animal *a2 = new Cat();
    a2->speak(); // 야옹 출력

    return 0;
}
```

**동적 바인딩**  
위에서는 어떤 식으로 자식의 speak가 출력되는 것일까요? 함수 호출을 함수의 몸체와 연결하는 것을 바인딩(binding)이라고 합니다. 바인딩에는 정적 바인딩과 동적 바인딩이 존재합니다.  

컴파일 단계에서 모든 것이 완료되는 것이 정적 바인딩(static binding)이라고 하고 반대로 바인딩이 실행 시까지 연기되고 실행 시간에 호출되는 함수를 결정하는 것을 동적 바인딩(dynamic binding) 또는 지연 바인딩(late binding)이라고 합니다.  

동적 바인딩을 사용하면 객체 지향의 중요한 특징 중의 하나인 다형성을 구현할 수 있습니다. 즉, 객체에 메시지를 보내면 객체가 메시지를 해석하여서 가장 적절한 동작을 하게 합니다. 

C++엣서는 가상 함수가 아니라면 모든 함수가 정적 바인딩으로 호출됩니다. 정적 바인딩은 호출 속도가 빠르지만 호출 함수가 컴파일 단계에서 항상 결정되므로 유연성이 떨어집니다. 동적 바인딩은 테이블을 사용하여서 실제 호출되는 함수를 결정하여야 하므로 처리 속도가 늦어집니다. 그렇지만 객체의 실제 타입에 맞는 알맞은 동작을 할 수 있습니다.  

*가상 함수 기능은 포인터와 참조자를 통해서만 가능하기에 객체를 값으로 전달하는 경우에는 동작하지 않습니다.*  

#### **참조자와 가상 함수**
앞에서는 포인터만을 이용하여 다형성을 설명하였습니다. 그렇다면 참조자인 경우에는 다형성이 동작할까요? 참조자도 포인터와 마찬가지로 모든 것이 동일하게 적용도됩니다. 즉, 부모 클래스의 참조자로 자식 클래스를 가리킬 수 있으며 가상 함수의 동작도 동일합니다.  

```C++
int main(){
    Dog d;
    Animal &a1 = d;
    a1.speak(); // 멍멍

    Cat c;
    Animal &a2 = c;
    a2.speak(); // 야옹

    return 0;
}
```

#### **가상 소멸자**
다형성을 사용하는 과정에서 소멸자를 virtual로 해주지 않으면 문제가 발생합니다. 왜 그럴까요? 다음과 같이 작성되어 있다고 생각해보겠습니다.  

```C++
Animal *a1 = new Dog();
```

이렇게 상향 형변환이 이루어졌습니다. 이제 이 객체 포인터가 소멸을 해서 소멸자를 호출한다고 해봅시다. 그러면 Animal 포인터이기에 Animal 클래스의 소멸자는 호출이 될 것입니다. 그렇다면 Dog 클래스의 소멸자는 호출이 될까요? 그렇지 않을 것입니다. 이것은 실제로는 Dog 객체이지만 컴파일러는 "Animal 포인터니깐 Animal 객체일 것이다."라고 생각을 하기에 Animal 소멸자만 호출하게 됩니다. 그렇게 되면 만약 Dog 클래스에 포인터와 같은 동적 할당 메모리가 있는 경우라면 메모리 누수를 발생시키게 됩니다. 이를 방지하기 위해 부모 클래스 즉, Animal 클래스 소멸자를 virtual로 선언해주어야 합니다. 소멸자를 가상 함수화 해주는 것입니다.  

#### **순수 가상 함수**
순수 가상 함수(pure virtual function)는 함수 헤더만 존재하고 함수의 몸체는 없는 함수입니다. 다음과 같이 작성합니다.  

```C++
virtual 반환형 함수이름(매개 변수 리스트) = 0;
```

이러한 순수 가상 함수를 하나라도 가지고 있는 클래스를 추상 클래스(abstract class)라고 합니다. 추상 클래스는 객체를 생성할 수 없습니다. 왜냐하면 구현되지 않은 멤버 함수를 가지고 있기 때문입니다. 그렇다면 이러한 추상 클래스는 왜 필요한 것일까요? 이는 추상적인 개념을 나타내거나 클래스와 클래스 사이의 인터페이스를 나타내는 용도로 사용됩니다. 추상 클래스는 멤버 함수의 원형만을 정의하는 것이고 그 구현은 자식 클래스에서 하게 됩니다. 즉, 자식 클래스는 반드시 순수 가상 함수를 구현하여야 합니다.  

여기서도 주의해야 할 점이 있습니다. 추상 클래스가 객체를 생성할 수 없다고 해서 추상 클래스를 가리키는 포인터를 만들지 못한다는 것은 아닙니다. 포인터 변수를 생성하여 이 포인터 변수를 통해 자식 클래스의 객체를 가리키는 것은 가능합니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  

*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*
