# **제어 구조**
프로그램 실행 흐름은 첫 번째 문장부터 실행하고 순차적으로 다음 문장을 실행한다. 그러나 이런 식으로만 프로그램이 동작한다면 많은 프로그램 상황에서는 적합하지 않을 수 있습니다.  
운전 시로 표현을 해본다면 무조건 직진만을 하는 것과 같습니다. 때에 따라서는 좌회전, 우회전, 후진 등의 행동이 필요한데 말입니다.  

순차 구조, 선택 구조, 반복 구조는 프로그램을 이루는 3가지의 중요한 제어 구조로 대부분의 프로그램은 3가지의 제어 구조를 조립하여 이루어집니다.  

#### **관계 연산자**
관계 연산자(relational operator)는 두 개의 피연산자를 비교하는데 사용됩니다. 이러한 관계 연산자의 결과는 참(true), 거짓(false)으로 계산된다. C++에서는 다음과 같은 6가지의 관계 연산자를 사용합니다.  

```
x == y // x와 y가 같은가?
x != y // x와 y가 다른가?
x > y // x가 y보다 큰가?
x < y // x가 y보다 작은가?
x >= y // x가 y보다 크거나 같은가?
x <= y // x가 y보다 작거나 같은가?
```

참이나 거짓을 저장할 수 있는 자료형은 bool로 bool 형식의 변수는 true 및 false 값을 가질 수 있습니다. 예를 들면 (1 == 2)같은 경우 false의 값을 가지게 됩니다.  

```C++
bool b = (1 == 2);

std::cout << std::boolalpha; // 이 문장이 없으면 b를 0으로 출력.
std::cout << b << endl;
```

현재에도 예전 프로그램과의 호환성을 위해 C++는 bool 타입과 int 타입이 서로 호환됩니다.  

#### **논리 연산자**
논리 연산자는 여러 개의 조건을 조합하여 참인지 거짓인지 따질 때 사용합니다. 예를 들어 "비가 오거나 눈이 오면 지하철을 이용한다."라는 문장에서 "비가 온다"는 조건과 "눈이 온다"는 조건 중에서 하나라도 만족되면 지하철을 이용한다는 의미가 포함되어 있음을 알 수 있습니다. 이렇듯 C++에서는 여러 조건들을 다양하게 묶을 수 있는 논리 연산자들이 준비되어 있습니다.

```
x && y // AND 연산, x와 y가 모두 참이면 참, 그렇지 않으면 거짓
x || y // OR 연산, x와 y 중 하나라도 참이면 참, 모두 거짓이면 거짓
!x // NOT 연산, x가 참이면 거짓, 거짓이면 참
```

## **if-else문**
if-else 문장은 주어진 조건이 참이냐 거짓이냐에 따라서 서로 다른 문장을 실행합니다.  

```C++
// if-else
if(조건식){
    ...
}
else{
    ...
}
```

if-else 문에서 조건식이 참이면 if block이 실행되고 거짓이라면 else block이 실행되게 됩니다.  

if-else 문은 극단적으로 조건식이 참, 거짓으로 이루어질때에만 사용될 수 있습니다. 그러나 실생활에서만 볼 수 있듯이 다양한 경우가 있을 수도 있습니다. 이럴때 사용하는 것이 바로 중첩 if-else문입니다.  

```C++
// 중첩 if-else
if(조건식1){
    ...
}
else if(조건식2){
    ...
}
else{

}
```

위 코드를 보면 조건식1이 참이라면 if block이 실행되고 조건식1이 거짓이라면 밑에 있는 else if block에서 조건식2가 참인지 거짓이지 확인하여 참이라면 else if block을 실행하고 조건식2까지 거짓이라면 최종적으로 else문을 실행하게 됩니다. 그러나 만약 조건식2도 참으로 들어가지만 조건식1도 참일때는 먼저 조건식1에서 걸려서 if block만을 실행합니다.  

else if 문은 여러 개를 삽입할 수도 있습니다. 즉, 조건을 여러개 더 입맛에 맞게 줄 수 있다는 뜻입니다.  

## **switch문**
switch문은 여러 개의 가능한 실행 경로 중에서 하나를 선택하는데 사용됩니다. 중첩 if-else문과 비슷하지만 정확하게 보면 다릅니다. switch문은 변수 하나에 대해서 그 변수가 어떤 값인가를 보지만 if-else문은 다양한 조건을 비교하면서 그 조건에 맞으면 그 block을 실행하는 것이기 때문입니다. switch문의 예제를 보면서 더 설명드리겠습니다.  

```C++
int number;
cin >> number;

switch(number){
    case 0:
        cout << "zero" << '\n';
        break;
    case 1:   
        cout << "one" << '\n';
        break;
    case 2:
        cout << "two" << '\n';
        break;
    default:
        cout << "another" << '\n';
        break;
}

return 0;
```

위의 switch 코드를 보게 되면 입력 받은 정수 변수 number에 대해서 number가 어떤 값인가에 따라 실행되는 block이 달라지게 됩니다.  
만약에 case block에 break문이 없게 된다면 (여기서 break는 switch문을 끝낸다는 의미) 그 case block 밑에 다른 case들도 전부 실행하게 되므로 그걸 원치 않는다면 break는 넣는 것이 좋습니다.  
마지막으로 default는 위의 case block에서 전부 걸리지 않았다면 최종적으로 실행되는 block입니다. 미처 예상하지 못한 값이 있을 수 있기에 default는 가급적 사용해주시는게 좋습니다.  

## **while문**
반복 구조는 같은 처리 과정을 여러 번 되풀이하는 구조로 while 루프는 조건이 맞는다면 계속해서 반복을 하는 구조입니다.  

```C++
while(조건식){
    ...
}
```

이러한 while 루프는 조건식이 참이면 계속해서 반복을 하다가 조건식이 거짓이 되면 루프를 탈출하게 됩니다.  

while문과 비슷하지만 느낌이 살짝 다른 do-while문도 있습니다. 이 do-while문은 do block을 먼저 실행 후 while의 조건식을 확인하는 것으로 처음부터 조건식이 맞지 않더라도 무조건 한번은 실행을 한다는 의미가 있습니다.  

```C++
do{
    ...
} while(조건식);
```

## **for문**
for 루프는 일정한 횟수만큼 반복할 때 유용하게 사용할 수 있습니다.  

```C++
for(초기식; 조건식; 증감식){
    ...
}
```

순서를 보게 되면 초기식을 실행한 후에 조건식이 참인 동안, 문장을 반복한다는 의미로 한번 반복이 끝날 때마다 증감식이 실행되어 초기식의 변수 값을 바꾸게 됩니다.  
- 초기식: 반복에 사용되는 변수를 선언하거나 초기화
- 조건식: 참이면 문장을 실행, 거짓이면 반복 종료
- 증감식: 한 번의 반복 뒤에 실행, 제어 변수를 증가하거나 감소시킴

## **break문**
앞 전에 switch문에서 먼저 언급되었었지만 break는 while, for문에서도 사용할 수 있습니다. 이 break 문은 반복 루프를 벗어나기 위하여 사용됩니다.  

만약 반복 루프가 진행 중에 break를 만나게 되면 해당 루프를 바로 종료시키고 루프를 탈출하게 됩니다.  

## **continue문**
continue 문은 현재 수행하고 있는 반복의 나머지 과정을 건너 뛰고 다음 루프로 간다는 의미입니다. 만약 continue를 만나게 되면 루프 내부의 continue 이후의 과정은 실행되지 않고 다시 루프의 가장 위로 이동하는 것입니다.  

# **배열**
배열(array)은 같은 종류의 데이터들이 순차적으로 메모리에 저장되는 자료 구조입니다. 여기서 같은 종류의 데이터들이란? 타입이 같은 데이터들을 의미하는 것입니다. 각각의 데이터들은 인덱스(번호)를 사용하여 독립적으로 접근되면 이러한 배열을 이용하면 대량의 데이터들을 동일한 이름으로 쉽게 저장하고 처리할 수 있게 됩니다.  

```C++
int arr[10] // 크기가 10인 이름이 arr인 배열
```

배열의 요소에는 인덱스(index) 또는 첨자(subscript)라고 부릅니다. 위처럼 배열의 이름이 arr이라면 arr[0], arr[1], arr[2], ..., arr[9]로 표시할 수 있게 됩니다. C++에서는 항상 배열 요소의 번호가 0부터 시작함을 명심해야 합니다.  

배열에 값을 저장하려면 배열 요소에 접근하여 저장해주면 됩니다. 저장하는 것은 위처럼 인덱스를 사용하면 됩니다.  
```C++
arr[5] = 20 // 인덱스 5에 있는 배열 요소에 20을 저장
```

#### **배열의 초기화**
그렇다면 배열은 어떻게 초기화할 수 있을까요? 배열은 여러 개의 요소로 이루어지기에 초기값 또한 하나가 아닌 여러 개가 필요하게 됩니다. 그러나 초기화 방법 또한 여러 개가 존재하기에 다음을 하나하나 살펴보도록 하겠습니다.  

```C++
int sales[5] = { 100, 200, 300, 400, 500 } // [100, 200, 300, 400, 500] 의 배열을 만든 것

int sales[5] = { 100, 200, 300 } // [100, 200, 300, 0, 0]의 배열을 만든 것, 빈 자리는 자동적으로 0으로 채워짐.

int sales[] = { 100, 200, 300, 400, 500, 600} // 배열의 크기를 지정하지 않았기에 자동적으로 [100, 200, 300, 400, 500, 600]의 크기가 6인 배열이 만들어짐.

int sales[5];

for(int i = 0; i < sales.size(); i++){
    salse[i] = i * 100; // i번째 인덱스에 i * 100의 값을 가지게 초기화됨.
}
```

그렇다면 배열의 모든 요소가 같은 값으로 초기화를 하려고 한다면 for문 혹은 직접 일일히 작성해줘야 하는 것일까요? 그렇지 않습니다. fill 함수와 memset 함수를 이용하여 배열을 초기화할 수 있습니다. 

**fill함수**  
fill함수는 다음과 같이 작성할 수 있습니다.  
```C++
fill({시작할 배열의 주소}, {끝나는 주소}, {초기화 할 값})

fill(arr, arr + 10, 5);
```
fill 함수를 다음과 같이 작성하면 arr이라는 배열은 5라는 값들로 초기화됩니다. 이때 보게 되면 처음에는 시작할 배열의 주소를 넣으라고 되어 있는데 배열 그 자체인 arr이 들어가신 것을 볼 수 있습니다. 이것은 오류가 아닌 기본적으로 배열의 이름은 배열의 가장 첫번째 요소를 가리키는 **포인터**라고 할 수 있습니다. 포인터라는 개념은 아직 학습하지 않았으니 이렇게만 정의하고 넘어가겠습니다.  

**memset함수**  
memset함수 또한 배열을 초기화하는 함수지만 이는 fill함수와 다릅니다. 어떤 부분이 다를까요? 일단 memset 함수가 fill 함수보다 속도가 월등하게 빠릅니다. 같은 작업이라도 20 ~ 30배 정도의 속도 차이를 가질 수 있습니다. 그렇다면 왜 fill 함수는 존재하며 memset만 사용하면 되는게 아닐까요? 결론부터 말씀드리자면 memset은 프로그래머가 원하는 대로 동작하지 않을 가능성이 있습니다. 그 이유에 대해 설명드리면 memset은 배열의 원소를 초기화하는 것이 아닌 1 바이트 단위로 메모리를 초기화하는 함수입니다. 다음은 memset의 형식입니다.  

```C++
memset({시작할 배열의 주소}, {초기화 할 값}, {길이})

memset(void* ptr, int value, size_t num);
```

만약 여기서 int형 배열을 memset을 이용하여 초기화해보겠습니다.  

```C++
int arr[5];

memset(arr, 0, sizeof(arr)); // sizeof(arr)은 arr의 크기라는 의미
```

이런 식으로 초기화를 한다면 arr 요소들의 값은 모두 0이 될 것입니다.  

```C++
memset(arr, 1, sizeof(arr));
```

그렇다면 1로 초기화를 시킨다면 모든 요소들의 값은 1일까요? 그렇지 않습니다. 위에서 말했듯이 memset은 1바이트 단위로 메모리를 초기화하는 함수기에 4바이트인 int를 1 바이트 단위로 1로 만든다고 해서 4바이트인 int의 1로 만들 수는 없는 것입니다. 0은 1바이트든 4바이트든 똑같이 0이기에 원했던 결과물을 얻을 수 있었던 것입니다.  

결론적으로 0이 아니거나 char 타입 혹은 bool 타입이 아니라면 원하는데로 초기화를 시킬 수 없다는 것입니다.  

#### **범위 기반 for 루프**
범위 기반 for 루프(range-based for loop)는 제어 구조 부분에서 설명했어야 하는거 아닌가?라고 생각하실 수도 있지만 배열 부분에서 설명하는 이유는 이는 배열대해서 사용할 수 있기 때문입니다.  

```C++
for(변수:범위){
    ...
}
```

여기서 범위는 배열, 컨테이너, 시퀀스 등이라고 생각하시면 됩니다. 아직은 배열에 대해서만 학습했기에 정수 배열에 대해서만 확인해보겠습니다. for루프는 범위 안의 모든 요소에 대하여 반복을 수행하게 되고 반복 시마다 변수가 요소의 값으로 설정됩니다.  

```C++
int list[] = { 1, 2, 3, 4, 5};

for (int i : list){
    cout << i << "'\n";
}
```

다음 코드를 보게되면 루프를 돌면서 list의 요소들에 차례차례 접근하게 되고 i의 값은 순차적으로 1, 2, 3, 4, 5로 초기화되게 됩니다. 그렇기에 출력 결과는 

```
1
2
3
4
5
```
다음과 같이 나타나게 될 것입니다.  

#### **2차원 배열**
다차원 배열은 배열의 배열(arrays of arryays)라고 불립니다. 예를 들어 2차원 배열은 요소로 이루어진 2차원 테이블을 상상하시면 됩니다. 바둑판이나 체스판 또한 2차원 배열의 예입니다.  

2차원 배열은 배열 요소들이 2차원으로 배열되어 있기에 행과 열을 나타내는 2개의 인덱스를 가집니다.  

```C++
int arr[3][5];

// arr[3][5]의 모습
---------------------
|   |   |   |   |   |
---------------------
|   |   |   |   |   |
---------------------
|   |   |   |   |   |
---------------------
```

다음과 같이 3개의 행에 5개의 열을 가지는 모습을 생각하시면 됩니다.  
위의 배열은 arr[0][0], arr[0][1], ..., arr[2][3], arr[2][4]까지의 모두 15개의 요소를 가지며 첫 번째 인덱스는 행번호이고 두 번째 인덱스는 열번호라고 합니다. 이때 arr[i][j]는 배열 arr의 i번째 행과 j번째 열의 요소입니다.  
항상 인덱스는 0부터 시작함을 명심함이 좋습니다.  

다차원 배열은 2차원에 국한되지 않으며 더욱 더 많은 차원을 가질 수 있습니다.  

**2차원 배열의 초기화**  
2차원 배열도 1차원과 마찬가지로 선언과 동시에 초기화할 수 있습니다. 다만 같은 행에 속하는 초기값들은 중괄호 {}로 따로 묶어주어야 합니다.  

```C++
int arr[3][5] = {
    {1, 2, 3, 4, 5},
    {6, 7, 8, 9, 10},
    {11, 12, 13, 14, 15}
}

int arr[3][5] = {} // 모든 요소 0으로 초기화. 
```

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*