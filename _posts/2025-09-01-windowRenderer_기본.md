---
layout: single
title:  "windowRenderer_기본"
categories: study
---

# 렌더링
**렌더링**이란 무엇일까요? 렌더링은 컴퓨터 그래픽스 즉, CG분야에서 2D 또는 3D 모델로부터 최종적인 영상(이미지 또는 동영상)을 만들어내는 과정을 의미합니다. 컴퓨터가 가지고 있는 데이터(점, 선, 면, 질감, 조명 등)를 사람이 볼 수 있는 하나의 완성된 그림으로 그려주는 작업이라고 할 수 있습니다.  

그래픽 처리 장치(GPU)는 바로 렌더링 파이프라인을 하드웨어로 만들어 놓은 것입니다.  
여기서는 이론들에 대해 설명하고 실제로 어떻게 사용했는지는 제 깃에 올린 코드를 보시면 이해가 가실 겁니다.

## 렌더링의 단계
### 1. 응용 단계(Application)
이 단계는 렌더링 파이프라인의 시작점으로, 주로 CPU가 담당합니다.  
이는 응용프로그램에서 그래픽처리작업에 필요한 '데이터'와 '명령문'을 조직화하여 그래픽처리장치로 전달하는 역할입니다.  

### 2. 기하 단계(GeoMetry)
이 단계부터는 전문화된 GPU가 작업을 이어받아 매우 빠른 속도로 처리합니다. 말 그대로 3D모델의 기하학적(Geometric)인 정보를 계산하는 단계로 핵심은 정점(Vertex)단위로 데이터를 처리하는 것입니다.  

기하 단계에서는 변환들을 수행하게 되는데 이때 순서는 월드 -> 뷰 -> 투영 -> 뷰포트 변환의 순서로 진행되게 됩니다. 변환이란 자기자신으로의 사상이라고 생각하면 되는데 함수의 느낌이라고 생각하시면 됩니다. 입력이 들어오면 출력을 뱉는 것입니다.  

#### 1. 월드 변환(World Transformation)
월드 변환에는 평행이동, 회전, 스케일이 있고 이는 각각의 3D모델(캐릭터, 건물 등)은 좌표계를 가지는데 이 모델들을 게임이나 영상 속 하나의 가상 세계(World Space)에 올바르게 배치하는 것입니다.  

#### 2. 뷰 변환(View Trasformation)
뷰 변환에는 평행이동, 회전이 있고 이는 가상세계의 놓인 물체들을 특정 시점(카메라)에서 바라보도록 전체 공간을 재배치하는 과정입니다. 실제로는 카메라를 움직이는 대신에 세상 전체가 카메라 앞에 와서 자리를 잡는 방식으로 계산하는 경우가 많습니다.  

#### 3. 투영 변환(Projection Transformation)
n -> n - 1 차원으로 투영하는 과정으로 실제 사용에서는 3차원에서 2차원으로 투영하는 아주 중요한 단계입니다.  
보통 원근 투영(Perspective Transformation)이 사용되는데 이는 원근감이 발생되는 투영으로 우리가 현실에서 세상을 보는 방식과 같습니다.  

#### 4. 뷰포트 변환(Viewport Transformation)
2D로 투영된 이미지를 우리가 보는 스크린(모니터, 스마트폰 화면 등)의 특정 영역(뷰포트)에 맞게 크기와 위치를 조절하는 마지막 단계입니다. 여기까지는 2D이지만 데이터는 3D의 데이터를 가지고 있습니다.  

이 모든 기하 단계는 실수(소수점) 기반의 연속된 공간에서 정점(Vertex) 데이터를 기준으로 정밀하게 계산됩니다. 이 계산은 GPU의 정점 셰이더(Vertex Shader)라는 부분에서 주로 담당합니다.  

### 3. 레스터라이즈 단계(Resterization)
기하 단계를 거친 정점 데이터는 이제 화면에 표시될 준비를 마친 2D 도형의 '뼈대'와 같습니다. 레스터라이즈 단계는 이 뼈대 안을 채워 최종 픽셀 이미지로 만드는 과정입니다.  

- 픽셀 데이터화: 정점 데이터로 표현된 2D 삼각형(폴리곤)들이 화면의 어떤 픽셀(Pixel)들을 덮고 있는지 판단하고, 각 픽셀에 어떤 색상을 칠할지 결정합니다. 조명, 텍스처, 그림자 등을 종합적으로 계산하여 최종 세상을 결정하게 됩니다.  
- 불연속적인 공간: 이 단계에서 데이터는 정점과 같은 연속적인 좌표가 아닌, 화면을 구성하는 격자무늬의 불연속적인 픽셀 단위로 처리됩니다. 

이 과정은 픽셀 셰이더(Pixel Shader)가 담당합니다.  

### 셰이더
위에서 얘기한 정점, 픽셀 셰이더에서 셰이더란 무엇인가? **셰이더**는 GPU에서 실행되는 작은 프로그램으로, 메쉬 데이터를 화면에 최종적으로 어떻게 그릴지 계산하는 역할을 합니다. 이 과정을 정점 셰이더와 픽셀 셰이더가 각각 맡아서 하게 되는 것입니다.  

1. 정점 셰이더: 메쉬를 구성하는 모든 정점 각각을 담당합니다. 수만 개의 정점이 존재한다면 정점 셰이더는 수만 번 독립적으로 실행됩니다.  

2. 픽셀 셰이더: 정점 셰이더의 작업이 끝난 후, 화면에 그려질 삼각형 내부의 모든 픽셀 각각을 담당합니다.



### 이러한 전체적인 렌더링 과정을 거쳐, 우리는 게임이나 영상에서 부드럽고 사실적인 3D 그래픽을 볼 수 있게 되는 것입니다.  

## 삼각형(Triangle)
삼각형이란 정점 3개로 만들어진 도형입니다. 갑자기 왜 삼각형에 대해 설명하냐면 삼각형은 3D 그래픽의 가장 기본적인 원자(atom)이기 때문입니다.  

삼각형이 이러한 원자인 이유는 어떤 3개의 점이든 항상 하나의 평면을 만든다는 것이 수학적으로 보장되기 때문입니다. 삼각형의 이웃한 임의의 두 변을 벡터로 보고 외적하면 이 결과 벡터들은 모두 같은 방향의 벡터가 나오게 됩니다. 평면은 법선벡터로 정의되기에 이 정점 3개는 같은 평면 상에 있게 되는 것입니다. 만약 사각형을 기본 단위로 쓴다면, 점 4개 중 하나가 비뚤어져 평면이 접히거나 왜곡이 될 수 있기 때문에 계산이 매우 복잡해지게 됩니다. 그러기에 삼각형을 원자로 사용하게 됩니다.  

그리고 이러한 삼각형 타일들을 수없이 이어 붙여 만든 3D 모델의 뼈대를 메쉬(Mesh)라고 부릅니다. 단순한 정육면체 큐브는 12개의 삼각형으로 이루어지지만 아주 정교한 게임 캐릭터는 수십만 개의 삼각형으로 이루어집니다.  

### 평면(Plane)의 벡터 방정식
평면의 벡터 방정식이란 평면을 대수적으로 표기한 방정식입니다.  
```
P dot N = d

N: 법선벡터(평면에 수직인 단위벡터)
P: 평면 위의 임의의 한 점
d: 원점과 평면 사이의 최단거리
```

삼각형은 평면이기에 방향을 가지게 됩니다. 이는 '앞면'과 '뒷면'이 있다는 것입니다. 이 방향을 알려주는 것이 바로 법선 벡터(Normal Vector)입니다.  

법선 벡터는 삼각형 평면에 수직인 방향을 가리키는 화살표(벡터)입니다. 이는 빛 계산때문에 극도로 중요하게 되는데 어떤 표면이 밝게 빛나거나 어둡게 보이는지는 빛이 그 표면에 어떤 각도로 부딪히는가에 따라 결정되는데, 이 각도를 계산할 때 기준이 되는 것이 바로 법선 벡터이기 때문입니다.  

## 은면 제거(Hidden face culling)
은면 제거란 렌더링 시에 카메라 시점에서 보이지 않는 물체나 물체의 일부(면)를 그리지 않도록 식별하고 제거하는 과정을 말합니다.  

3D 공간 상에는 수많은 물체들이 겹쳐 있지만, 최종적으로 화면에 보이는 것은 가장 앞에 있는 물체의 표면입니다. 은면 제거가 없게 된다면 굳이 보이지 않는 부분들도 다 그리게 될 것이기 그렇게 되면 화면 자체도 비정상적으로 보이면서 필요없는 렌더링까지 하므로 연산량이 더욱 많이 늘어나게 되어 성능에도 영향을 주게 될 것입니다. 그렇기에 이는 효율적인 렌더링을 위해서라도 꼭 필요한 과정이라고 할 수 있습니다.  

은면 제거에는 후면 컬링, 전면 컬링, 컬링 없음 이렇게 3가지가 존재하는데 후면 컬링은 후면을 그리지 않겠다, 전면 컬링은 전면을 그리지 않겠다, 컬링 없음은 컬링을 하지 않겠다라는 의미입니다.  

가장 현대적으로 사용되는 은면 제거 알고리즘으로는 Z-버퍼(Z-Buffer) / 깊이 버퍼(Depth Buffer)라는 방법이 있습니다. 이는 둘 다 같은 말입니다.  

### 깊이 버퍼(Depth Buffer)
이 방법은 화면에 출력될 픽셀의 색상 정보 말고도 각 픽셀의 깊이(카메라로부터의 거리) 정보만을 저장하는 Z-버퍼라는 메모리 공간을 사용하는 방법입니다.  

- 작동 방식  
  1. Z-버퍼를 가장 먼 값(무한대)로 초기화합니다.
  2. 어떤 픽셀을 그리려고 할 때, 먼저 해당 픽셀의 깊이 값을 Z-버퍼에 저장된 값과 비교합니다.
  3. 새로 그릴 픽셀이 더 가깝다면(깊이 값이 작다면) 컬러 버퍼에 해당 픽셀의 색을 칠하고 Z-버퍼의 값도 이 새로운 깊이 값으로 업데이트합니다.
  4. 만약 더 멀다면 해당 픽셀을 무시하고 아무것도 그리지 않습니다.

이 방식은 대부분의 그래픽 카드에서 하드웨어적으로 지원합니다.

### 후면 컬링 (Back face culling)
이는 앞면과 뒷면을 구분하여 카메라를 등지고 있는 뒷면(후면)을 아예 렌더링시키지 않는 방법입니다.  

- 작동 방식  
  1. 각 면의 방향을 나타내는 법선 벡터와 카메라 시선 방향을 비교합니다.
  2. 두 벡터가 이루는 각도가 90도 이상이면 그 면은 후면으로 판단하여 그리지 않습니다.

이 방법은 렌더링해야 할 삼각형의 수를 거의 절반으로 줄여주기에 성능 향상에 효과적으로 Z-버퍼와 함께 가장 기본적으로 사용되는 최적화 기법입니다.  

## 셰이딩(Shading)
셰이딩은 3D 컴퓨터 그래픽스에서 3D 모델 표면의 각 픽셀 색상을 결정하여 물체의 입체감, 질감, 명암을 표현하는 과정을 말합니다. 셰이딩이 없다면 모든 물체는 단색의 밋밋한 덩어리로만 보일 것이기에 더욱 사실적인 표현을 위해 필요한 과정입니다. 이는 픽셀 셰이더에서 주로 담당합니다.  

셰이딩은 다음과 같은 요소들을 종합적으로 계산하여 각 픽셀의 최종 색상을 결정하게 됩니다.

- 광원(Light Source): 빛의 종류(점 광원, 태양광 등), 위치, 색상, 세기
- 물체의 표면 특성(Surface Properties)
  - 알베도(Albedo): 물체가 가진 고유의 색상 또는 텍스쳐
  - 법선 벡터(Normal Vector): 표면의 기울어진 방향. 빛을 어느 각도로 반사할지 결정하는 핵심 요소
- 카메라 위치(Camera Position): 관찰자의 시점에서 표면이 어떻게 보이는지
- 그림자(Shadows): 다른 물체에 의해 빛이 가려졌는지 여부

### 셰이딩 기법의 발전
1. 플랫 셰이딩(Flat Shading)
   - 가장 단순하고 빠른 셰이딩 기법
   - 하나의 삼각형 전체를 단일한 색상으로 칠합니다.
2. 구로 셰이딩(Gouraud Shading)
   - 삼각형의 각 정점(Vertex)에서만 조명 계산을 수행하고, 그 사이의 색상은 선형 보간하여 채웁니다.
   - 플렛 셰이딩보다는 훨씬 부드러운 표면을 연출하지만 정점에서만 계산하기에 하이라이트가 정확하게 표현되지 않을 수 있습니다.
3. 퐁 셰이딩(Phong Shading)
   - 구로 셰이딩을 개선한 방식으로 모든 픽셀 단위로 조명을 계산합니다.
   - 정점의 법선 벡터를 보간한 후, 각 픽셀마다 정확한 조명 계산을 수행하여 매끄럽고 사실적인 하이라이트 표현이 가능합니다.

제 깃의 코드에서는 하프-램버트(Half-Lambert) 조명 모델을 사용한 플랫 셰이딩으로 구현하였습니다.  
여기서 하프-램버트 조명 모델이란 법선 벡터(N)와 광원 벡터(L)를 내적하여 광량을 계산하는 방식입니다.  
기본 램버트 모델의 내적은 -1 ~ 1의 값을 갖는데 이때 값이 0보다 작으면 빚을 등진 상태로 판단하여 완전히 검게 표현되는데 이는 입체감을 떨어뜨릴 수 있어 하프-램버트 모델이 사용되었습니다.  

### 기본적으로 행렬 등과 같은 수학개념을 필요로 하고 좀 더 많은 이론적 내용들이 있지만 여기서는 수업에서 큰 틀을 차지한 내용들을 설명하였습니다.  
### 제가 수업을 들으며 내용을 다시 상기시키기 위해 작성하는 것으로 미처 오류를 범하는 부분이 있을 수도 있습니다.  
