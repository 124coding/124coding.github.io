# 상속
이번에는 상속에 대해 학습하겠습니다. 앞 전에서도 몇 번 상속에 대해 언급된 적이 있었지만 코드 재사용을 위해 사용한다고만 했는데 이번에 상속에 대해 자세히 한번 알아보겠습니다.  

#### **상속의 개요**
상속이라는 단어가 평상시에 어떻게 쓰이는지는 아실 것입니다. 부모의 재산을 자식이 물려받는 것이죠. 객체 지향의 상속도 비슷한 의미로 사용됩니다. 이는 기존에 존재하는 클래스로부터 속성과 동작을 이어받고 자신이 필요한 기능을 추가하는 기법입니다. 상속은 이미 작성된 검증된 소프트웨어를 재사용하면서 손쉽게 개발, 유지 보수를 하게 해주는 중요한 기능으로 코드의 중복 또한 줄일 수 있어서 전체적으로 코드를 읽기도 쉬어집니다.  

**상속**  
상속(inheritance)이란 이미 존재하는 클래스로부터 멤버들을 물려받는 것입니다. 이미 존재하는 클래스는 부모 클래스(parent class)라고 하며 상속을 받는 클래스를 자식 클래스(child class)라고 합니다.  

```C++
class Child : 접근지정자 Parent{
    ...
}

// 예를 들어 과일에 비유
class Fruit{
    int price;
}

class Apple : public Fruit{
    string color;
}
```

자식 클래스는 부모 클래스가 가지고 있는 모든 멤버들을 전부 상속받고 자신이 필요한 멤버를 추가하기에 항상 자식 클래스가 부모 클래스를 포함하게 됩니다. 그렇기에 상속을 나타낼 때 확장(extend) 또는 파생(derive)라는 용어를 사용합니다.  

**상속되는 것**  
그렇다면 어떤 것들이 상속되는 것일까요? 부모 클래스의 멤버 변수와 멤버 함수가 자식 클래스로 상속됩니다. 따라서 자식 클래스는 부모 클래스의 멤버 변수와 멤버 함수를 자유롭게 사용할 수 있습니다. 자식 클래스는 필요 시 자신만의 변수와 멤버 함수를 추가시킬 수도 있고 부모 클래스에 이미 존재하는 멤버 함수를 새롭게 정의하여 사용할 수도 있습니다. 상속된 변수나 멤버 함수는 원래의 가시성을 유지합니다. 즉 부모 클래스에서 public이었으면 자식 클래스에도 public이 됩니다.  

#### **상속의 필요성**
상속을 사용하면 중복되는 코드를 많이 줄일 수 있습니다. 만약 상속없이 비슷한 느낌의 클래스들을 구현한다고 하면은 겹치는 코드들이 많이 존재할 수 있습니다. 공통 부분이 하나로 정의되어 있게 된다면 이는 유지 보수도 쉽고 변경에도 용이합니다.  

**is-a 관계**  
상속에서 자식 클래스와 부모 클래스는 "~은 ~이다"와 같은 is-a 관계입니다. 예를 들어 "사과는 과일이다"같은 느낌입니다. 따라서 상속의 계층 구조를 올바르게 설계하였는지를 생각하려면 is-a 관계가 성립하는지 확인하시면 됩니다.  

만약 "~은 ~을 가진다."와 같은 has-a(포함) 관계가 성립된다면 이는 상속으로 모델링 해선 안됩니다. 예를 들면 "자동차는 엔진을 가진다"와 같은 느낌입니다. 자동차와 엔진은 상속으로 표현할 수 없듯이 has-a관계가 성립되면 이는 상속으로 표현될 수 없습니다. 이런 has-a 관계는 하나의 클래스 안에 다른 클래스의 객체를 포함시키는 방향으로 구현해야 합니다.  

#### **상속과 생성자/소멸자**
자식 클래스의 객체가 생성될 때에 당연히 자식 클래스의 생성자는 호출이 됩니다. 그렇다면 부모 클래스의 생성자는 호출될까요? 자식 클래스가 부모 클래스를 포함하고 있으니깐 부모 클래스의 생성자도 호출되어야 하는 것이 논리적이지 않을까요? 실제로 자식 클래스의 생성자에서 가장 먼저 하는 일이 부모 클래스의 생성자를 호출하는 일입니다. 만약 특별하게 지정하지 않는 다면 부모 클래스의 기본 생성자를 컴파일러가 자동으로 호출하여 실행하게 됩니다.  

소멸자의 경우에는 역순으로 호출되게 됩니다. 즉 자식 클래스의 소멸자가 먼저 호출되고 부모 클래스의 소멸자가 호출되는 것입니다.  

**부모 클래스의 생성자를 지정하는 방법**  
부모 클래스의 생성자를 지정하지 않으면 항상 기본 생성자가 호출됩니다. 그렇다면 매개 변수가 있는 다른 생성자를 호출하려면 어떻게 해야 할까요? 이때에는 자식 클래스 생성자의 헤더 뒤에 콜론(:)을 추가한 후에 원하는 부모 클래스의 생성자를 적어주면 됩니다.  

```C++
자식클래스의 생성자() : 부모클래스의 생성자(){

}

class Car {
    int speed;

    Car(int speed) : speed(speed) {}
};

class SportsCar {
    int turbo;

    SportsCar(int speed, int turdo) : Car(speed), turbo(turbo) {}
    // 혹은 다음과 같이 작성도 가능합니다.
    SportsCar(int speed, int turdo) : Car(speed) {
        this->turbo = turbo;
    }
}
```

#### **접근 지정자**
상속이 도입되기 전까지는 private과 public 2개의 접근 지정자만을 사용했습니다. 상속이 도입되면서 protected라고 하는 접근 지정자가 하나 더 필요하게 되었습니다. 이는 상속된 자식 클래스의 객체에서는 접근 가능한 멤버라는 의미입니다.  

```
-------------------------------------------
접근 지정자 | 자기 클래스 | 자식 클래스 | 외부
-------------------------------------------
private   |     o      |     x     |  x
-------------------------------------------
protected |     o      |     o     |  x
-------------------------------------------
public    |     o      |     o     |  o
-------------------------------------------
```

#### **멤버 함수 재정의**
만약 상속받은 멤버 함수의 변경이 필요하면 어떻게 하면 될까요? 이 경우에는 멤버 함수 재정의를 하면 됩니다. 재정의는 오버라이딩(overriding)이라고도 부릅니다. 이는 자식 클래스가 필요에 따라 상속되 멤버 함수를 재정의하여 사용하는 것을 의미합니다.  

```C++
class Animal{
public:
    void speak(){
        cout << "동물 소리" << endl;
    }
};

class Dog : public Animal {
public:
    void speak(){
        cout << "멍멍" << endl;
    }
};

int main() {
    Dog d;
    d.speak();

    return 0;
}
```

위처럼 코드를 작성하여 Dog 클래스가 Animal을 상속받을때 Dog 객체를 만들어 speak 함수를 호출하게 되면 이는 Animal의 멤버가 아닌 Dog의 멤버인 speak가 호출되게 됩니다. 이는 재정의된 함수가 우선권을 가지기 때문입니다.  

**재정의의 조건**  
재정의는 멤버 함수의 헤더는 그대로 두고 멤버 함수의 몸체만을 교체하는 것입니다. 멤버 함수의 헤더 부분은 부모 클래스의 헤더와 동일하여야만 합니다. 즉, 멤버 함수의 이름, 반환형, 매개 변수와 자료형이 일치하여야 한다는 것입니다.  

**부모 클래스의 멤버 함수 호출**  
그렇다면 재정의에 사용된 부모의 멤버 함수는 더 이상 부를 수 없게 된 것일까요? 그렇지 않습니다. 범위 연산자인 ::을 사용하여서 부모클래스의 멤버 함수를 부를 수 있습니다. 위의 예시를 예로 들면 다음과 같이 작성하면 부모의 멤버 함수가 출력됩니다.  

```C++
d.Animal::speak();
```

#### **부모 클래스를 상속받는 3가지 방법**
이제까지는 항상 부모 클래스를 상속 받을때 접근지정자로 public을 사용하였습니다. 일반적으로 가장 많이 사용하는 것이 public 상속은 맞으나 protected, private으로도 부모 클래스를 상속 받는 것이 가능합니다. 각 접근 지정자로 상속을 받게 되면 다음 표와 같이 각 접근 지정자의 멤버들이 변경되게 됩니다.  

```
-------------------------------------------
                    | public      | protected   | private
-------------------------------------------
부모의 public 멤버    | ->public    | ->protected | ->private
-------------------------------------------
부모의 protected 멤버 | ->protected | ->protected | ->private
-------------------------------------------
부모의 private 멤버   | ->private   | ->private   | ->private
-------------------------------------------
```

부모 클래스 앞에 어떤 접근 지정자를 쓰냐에 따라 상속 멤버의 접근 지정자가 달라지게 됩니다.  

#### **다중 상속**
다중 상속(multiple inheritance)이란 하나의 자식 클래스가 두 개 이상의 부모 클래스로부터 멤버를 상속받는 것을 의미합니다.  

```C++
class Sub : public Sup1, public Sup2{
    ...
}
```

위를 보게 되면 두 개의 클래스로부터 상속을 받음을 확인할 수 있습니다. 

**다중 상속의 문제점**  
다중 상속의 문제점으로는 만약 상속 받는 클래스들의 멤버 변수명이나 함수명이 같다면 그냥 그 변수에 대해 사용할때 컴파일 오류를 일으킬 수 있다는 것입니다. 당연히 컴파일러 입장에서는 어떤 클래스의 멤버인지를 모르니 당연합니다. 이럴때는 :: 범위 연산자를 이용하여서 어떤 클래스의 멤버인지를 표현해주어야 합니다. 이러한 다중 상속은 이해가 어렵고 미묘한 문제들이 발생할 수 있기에 주의하여서 사용해야 합니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*
