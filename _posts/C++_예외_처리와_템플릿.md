# 예외 처리와 템플릿
이번에는 예외 처리와 템플릿에 대해 학습하겠습니다. 예외 처리는 프로그래머가 다양한 예외 즉, 오류에 대해 상정하여 프로그램이 오류를 만났다고 꺼져버리는 것이 아닌 다른 행동을 할 수 있게 하는 것이고 템플릿은 타입에 대해 비교적 자유롭게 함수나 클래스를 작성할 수 있게 해주는 것입니다. 자세히 한번 배워보겠습니다.

#### **예외 처리**
이 세상에 완벽한 프로그램은 없습니다. 어떤 프로그램이든지 잘못된 코드, 부정확한 데이터, 예외적인 상황 등 다양한 상황들로 인해 오류(error)가 발행할 수 있습니다. 대개의 경우 오류가 발생하면 프로그램이 종료되게 됩니다. 그럴때 무작정 종료를 시키기보다는 오류를 감지하여 우아하게 프로그램을 종료하거나 오류를 처리한 후에 계속 프로그램이 실행된다면 더 나은 프로그램이 될 수 있을 것입니다. 이것을 예외 처리(exception handling)라고 합니다.   

**전통적인 예외 처리 방식**  
전통적으로 예외를 처리하는 방식은 여러분도 쉽게 생각할 수 있는 방식입니다. 맞습니다. if-else문을 이용하는 것입니다. 하지만 이렇게 if-else문을 이용하게 되면 조건이 많아졌을때 상당히 복잡하고 어떤 코드가 오류 처리 코드인지를 구별하기가 어렵게 됩니다. 함수 안에서 오류가 발생하면 보통 함수의 반환값으로 오류가 일어났음을 알리게 됩니다. 하지만 이런 방법은 정상적인 처리에서는 함수의 반환값을 사용할 수 없게 합니다.  

#### **예외 처리기**
예외 처리 과정을 개선하기 위한 많은 노력들이 있어 왔습니다. C++에서는 언어 차원에서 예외 처리 형식을 제공합니다. C++의 예외 처리는 try, throw, catch의 키워드를 사용합니다. 다음이 기본 형식입니다.  

```C++
try{
    // 예외 발생 가능 코드
    if(예외 발생 시){
        throw exception;
    }
} catch (예외타입 매개 변수){
    // 예외 처리 코드
}
```

먼저 try 블록에는 예외가 발생할 가능성이 있는 문장이 들어갑니다. 만약 예외 조건이 감지되면 throw 문장을 사용하여 예외를 던집니다. 예외가 발생되었다는 것을 예외를 던진다고 표현합니다. 예외가 던져지면 이 예외를 처리하는 catch문으로 점프합니다. catch 블록에는 처리할 수 있는 예외의 타입을 지정하고 예외를 처리하기 위한 코드가 들어갑니다.  

**try / catch 블록에서의 실행 흐름**  
try/catch 블록에서 예외가 발생하는 경우와 발생하지 않는 경우의 실행 흐름을 비교해보겠습니다.  

```C++
1. int pizza = 0;
2. int persons = 0;
3. int pizza_per_person = 0;

4. try{
5.     cout << "피자는 몇 개인가?" << endl;
6.     cin >> pizza;
7.     cout << "사람은 몇 명인가?" << endl;
8.     cin >> persons;

9.     if(persons == 0) throw persons;
10.    pizza_per_person = pizza / persons;

11.    cout << "한 사람 당 피자는 " << pizza_per_person << "개 가집니다." << endl;
12.} catch (int e) {
13.    cout << "사람이 0명입니다." << endl; 
}
```

코드가 다음과 같이 있다고 보겠습니다. 이는 나눗셈에서 0이 나눠지면 안되는 DevideZero 오류를 체크하는 코드입니다.  

만약 오류가 없었다면? 실행 순서는 다음과 같을 것입니다. 먼저 8번까지 쭉 실행합니다. 그런 후 9번 if문이 맞지 않음을 확인 후 10 -> 11이 수행되고 프로그램이 종료될 것입니다. 즉, catch문에는 들어가지 않는다는 것입니다.  

오류가 있었다면 어떻게 실행될까요? 8번까지는 쭉 실행이 될 것입니다. 그런 후 9번에서 persons가 0임을 확인하고 persons를 오류 문구로 던지게 될 것입니다. 이를 catch(int e) 즉, 12번에서 잡게 됩니다. 그리고 13번까지인 catch 문이 수행되고 프로그램이 종료될 것입니다.  

**catch 블록의 매개 변수**  
위의 예제에서도 알 수 있듯이 catch 블록은 함수는 아니지만 매개 변수를 가지고 있다는 점에서 함수와 유사합니다. catch 블록은 흔히 예외 처리기(exception handler)라고 불립니다. 이때 매개 변수 e는 어떤 역할을 할까요? 이는 함수의 매개 변수와 같은 역할을 하는데 throw 문장에서 던진 값이 바로 매개 변수 e를 통하여 예외 처리기로 전달되는 것입니다. 어떤 타입도 가능하기에 다양한 타입을 사용할 수 있습니다. 예제에서는 persons가 정수형이었기에 int e로 잡았음을 확인 가능합니다. 이는 문자열 심지어 더 복잡하다는 경우에는 클래스 타입도 가능합니다.  

**타입이 일치되는 예외만 처리**  
한 가지 주의할 점은 throw에서 던진 값의 타입과 catch 블록의 매개 변수의 타입이 일치해야만 예외가 처리됩니다. 만약 앞에서 persons는 정수형인데 매개 변수 e가 char타입이었다면? 이는 예외 처리가 되지 않았을 것입니다.  

만약 모든 예외를 잡고 싶다면 매개 변수를 ...으로 표시하면 됩니다.  

```C++
catch(...){}
```

#### **예외 전달**
예외는 함수 범위를 넘어서 전달 가능합니다. 실제로 만약 함수 안에서 예외가 처리되지 않았다면 이는 해당 함수를 호출한 함수로 넘어갑니다. 던져진 예외를 처리할 때까지 함수 호출 체인을 따라가면서 예외의 타입과 같은 예외 처리기를 갖습니다.  

만약 예외가 처리되지 않으면 시스템 라이브러리 함수인 abort()가 호출되어서 프로그램을 종료하게 됩니다.  

**표준 예외**  
C++ 표준 라이브러리에서 예외가 발생하면 std::exception이라는 특별한 예외가 발생하며 <exception>헤더에 정의됩니다. 이것을 처리하려면 catch(exception& e){} 블록이 필요합니다.  

#### **다중 catch 문장**
하나의 try 블록에서는 여러 개의 throw 문장을 사질 수 있습니다. 각각의 throw 문장은 타입이 다른 값을 던질 수 있습니다. 만약 여러 가지 타입의 값을 처리하려면 여러 개의 catch 블록을 두어야 합니다. 이렇게 다중 catch 블록을 둘 때는 더욱 구체적인 예외를 먼저 앞에 두어야 합니다. 만약 ...처럼 모든 예외를 잡는 매개 변수를 가진 catch 블록을 가장 앞에 두면 그 뒤의 catch 블록은 아무 일도 하지 못하게 될 것입니다. 따라서 구체적인 예외를 먼저 쓰고 일반적인 예외는 나중에 쓰는 것이 좋습니다. 즉, 범위가 작은 것에서 큰 것 순서로 작성해야 합니다.  

#### **함수 템플릿**
템플릿(template)이란 물건의 본을 떠 놓은 것으로서 물건을 만들 때 사용되는 틀이나 모형을 의미합니다. 예를 들어 여러 도형을 그리기 위한 모양자도 템플릿이라고 할 수 있습니다.  

C++에서도 하나의 형틀을 만들어서 다양한 코드를 생산해 내도록 할 수 있는데 이것을 템플릿이라고 합니다. 함수 템플릿(function template)은 함수를 찍어내기 위한 형틀입니다. 예를 들어 매개 변수를 2개 받고 두 변수 중 더 큰 값을 반환하는 함수에 대해 생각해보겠습니다.  

```C++
int get_max(int x, int y){
    if(x > y) return x;
    else return y;
}
```

다음과 같이 정수형에 대해 함수를 작성했다고 해보겠습니다. 근데 이제 실수형에 대해서 다음 함수가 필요하다고 해보겠습니다. 그렇다면 float 타입으로 다음 함수를 또 작성하여서 사용하여야 합니다. 너무 불편하게 느껴지시는 않으시나요? 타입만 다르고 함수의 핵심적인 부분은 다 같은데 또 그에 대한 함수를 작성해야 하는 것입니다. 이러한 문제를 해결하기 위해 일반화 프로그래밍(generic programming)이 제안되었습니다.  

일반화 프로그래밍은 용어 그대로 일반적인 코드를 작성하고 이 코드를 정수나 문자열과 같은 다양한 타입에 대하여 재사용하는 프로그래밍 기법입니다. 일반화 프로그래밍을 사용하면 하나의 코드로 정수도 처리할 수 있고, 실수도 처리할 수 있고 다양한 타입에 대해 처리가 가능해지는 것입니다. 위의 get_max 함수를 일반화 프로그래밍을 적용하여 함수 템플릿으로 다시 정의해보겠습니다.  

```C++
template<typename T>
T get_max(T x, T y){
    if (x > y) return x;
    else retunr y;
}
```

위의 코드를 살펴보면 자료형이 변수처럼 표기되어 있음을 확인할 수 있습니다. T 대신에 int를 넣으면 정수값 중에서 최댓값을 구할 수 있는 함수가 되고 T 대신에 float를 넣으면 실수값 중에서 최대값을 구할 수 있는 함수가 됩니다. 여기서 template<typename T>는 컴파일러에게 T가 타입의 이름으로 사용된다는 것을 알리기 위해 사용됩니다. 이 문구가 없으면 컴파일 오류를 발생시키게 됩니다.  

위처럼 템플릿 함수 정의를 한 것은 실제 함수를 정의한 것은 아닙니다. 함수를 생성해주는 틀만 정의한 것입니다. 실제 함수는 함수를 호출하는 순간에 생성됩니다. 즉, 템플릿에 주어진 매개 변수의 타입에 따라서 적절한 함수가 생성되는 것입니다.  

```C++
get_max(20, 30);
```

위처럼 함수를 호출하게 되면 int 타입을 매개 변수로 받는 함수가 생성되는 것입니다. 이렇게 그때그때 맞는 함수로 생성되는 것을 템플릿 함수의 인스턴화라고 합니다. 템플릿 함수에는 정수형이나 실수형뿐만 아니라 구조체나 클래스 형도 인자로 전달할 수 있습니다.  

**매크로와의 비교**  
```
#define get_max(x, y) ((x) > (y) ? (x) : (y))
```
이 매크로와 위의 함수 템플릿은 어떤 차이가 있을까요? 일단 매크로도 타입에 무관하게 작동되므로 일반화 프로그래밍의 한 형태로 볼 수 있습니다. 매크로를 정의하여 사용하는 것은 유용하지만 완벽하게 타입에 안전한 방법은 아닙니다. 매크로를 사용하는 것에 따른 문제점은 매개 변수가 여러 번 계산될 수 있다는 것이며 또한 사용자는 타입의 변환이 부적절한데도 불구하고 타입을 혼합하여 사용할 수 있습니다.  

**함수 템플릿의 특수화(template specialization)**  
함수 템플릿을 정의해 사용하다가 특수한 매개 변수에 대해서만 다른 동작을 하고 싶은 경우에는 템플릿 특수화 기능을 사용할 수 있습니다.  

```C++
template<typename T>
T get_max(T x, T y){
    if (x > y) return x;
    else retunr y;
}

template<>
string get_max(string x, string y){
    if (x[0] > y[0]) return x;
    else return y;
}
```

다음과 같이 작성하게 되면 x, y가 string인 경우에는 밑의 함수가 호출되게 되는 것입니다.  

**함수 템플릿과 함수 중복 정의**  
함수 템플릿은 특정한 경우에는 동작하지 않을 수 있습니다. 위의 get_max에서 만약 배열이 값으로 들어오게 된다면 이는 동작하지 않고 오류가 발생할 것입니다. 배열에 대해서도 get_max()가 동작되게 하려면 배열에 대해서도 동작할 수 있게 함수를 중복 정의하여야 합니다. 중복 정의된 함수는 템플릿 형태보다 우선 순위가 높습니다.  

**두 개의 타입 매개 변수를 갖는 함수 템플릿**  
다음과 같은 함수 템플릿이 있다고 해보겠습니다.  

```C++
template<typename T>
void print(T a, T b){
    cout << a << ' ' << b << endl;
}
```

이제 호출을 해보겠습니다.  

```C++
int a = 0, b = 0;
print(a, b); // 0 0
```

이러한 경우에는 템플릿 함수가 전혀 문제없이 동작할 것입니다. 그렇다면 다음과 같은 상황이라면 어떨까요?  

```C++
int a = 0;
double b = 0.0f;
print(a, b); // error
```

위처럼 작성하게 된다면 오류가 발생하여 컴파일되지 않을 것입니다. 이럴때는 그냥 두고 봐야만 할까요? 아닙니다 타입 매개 변수를 하나 더 사용하는 템플릿 함수를 작성하므로 해결할 수 있습니다.  

```C++
template<typename T1, typename T2>
void print(T1 a, T2 b){
    cout << a << ' ' << b << endl;
}
```

#### **클래스 템플릿**
클래스 템플릿(class template)도 함수 템플릿과 비슷합니다. 다만 이번에는 함수를 찍어내는 틀이 아니라 클래스를 찍어내는 틀(template)이라는 점만 다르게 됩니다.  

```C++
class Box{
    int x;
public:
    Box(int x = 0) : x(x) {};
};
```

위의 Box 클래스는 int형 데이터에 대해서만을 받을 수 있을 것입니다. 이러한 Box 클래스에 여러 가지의 타입을 담고 싶은데 이는 가능할까요? 템플릿을 사용하면 가능합니다. 템플릿을 사용하면 어떻게 작성할 수 있는지 확인해보겠습니다.  

```C++
template<typename T>
class Box{
    T x;
public:
    Box(T x) : x(x) {};
};
```

T는 클래스 내부라면 어디서든지 사용할 수 있습니다. 여기서 T는 바로 타입을 나타내며 이러한 타입은 기초형일 수도 사용자 정의형이 될 수도 있습니다. 이렇게 정의된 클래스 템플릿을 사용할 때는 클래스 이름 뒤에 자료형을 붙여서 사용할 수 있습니다.  

```C++
Box<int> box1;
Box<float> box2;
Box<double> box3;
```

클래스 템플릿은 클래스가 아니고 클래스를 생성하는 틀에 불과하기에 구체적인 타입이 주어지지 않는다면 클래스가 생성되지 않습니다. 구체적인 타입이 주어지면 그때에 클래스를 생성하게 되는 것입니다.  

**클래스 외부에 멤버 함수를 정의하는 경우**  
멤버 함수를 클래스 외부에 정의하는 경우에는 함수 템플릿처럼 함수 정의 앞에 template<typename ...>을 작성하여 주어야 합니다. 멤버 함수를 정의할 때마다 앞에 써줘야 함에 유의하여야 합니다.  

```C++
template<typename T>
class Box{
    T x;
public:
    Box(T x);
};

template<typename T>
Box<T>::Box(T x){
    this->x = x;
}

// 다른 멤버 함수들이 있다면 생성자처럼 작성해주면 됩니다.  
```

이것은 상당히 번거롭게 형식이지만 이렇게 하지 않으면 컴파일러가 T를 템플릿 매개 변수로 인식하지 못합니다.  

**클래스 템플릿의 사용**  
1. 클래스 템플릿의 매개 변수의 타입에도 디폴트값을 부여할 수 있습니다.  

```C++
template <typename T = int>
class MyClass{
    ...
}

MyClass<> c; // 만약 디폴트값이 부여되어 있다면 위처럼 타입 매개 변수 생략이 가능합니다.  
```

2. 클래스 템플릿을 사용하여서 포인터나 레퍼런스도 정의 가능합니다.  

```C++
MyClass<int> *pC;
```

3. 위처럼 타입을 지정해주기가 귀찮다면 이를 typedef 문장을 이용하여 간단한 이름으로 만들어서 사용할 수도 있습니다.  

```C++
typedef MyClass<int> iClass;

iClass c;
```

4. 함수의 매개 변수나 반환형으로도 사용이 가능합니다.  

```C++
void sub(MyClass<int>& c);
```

5. 템플릿에서 생성된 클래스로부터 상속하는 것도 가능합니다. 다음 문장은 MyClass<int> 클래스로부터 상속받아서 새로운 클래스를 정의합니다.  

```C++
class AdvancedClass : public MyClass<int> {
    ...
}
```

**템플릿 사용의 장점**  
템플릿으로부터 실제로 클래스를 생성하기 전까지는 코드가 생성되지 않습니다. 따라서 템플릿은 아무리 많아도 코드의 크기를 증가시키지 않는다는 장점이 있습니다. 따라서 라이브러리를 템플릿 형태로 제공할때 장점이 많습니다. 라이브러리 안의 템플릿 중에서 사용자가 실제로 타입 매개 변수를 주어서 사용한 템플릿만 코드로 변환되게 되며 나머지 템플릿은 코드 공간을 차지하지 않는다는 장점이 있습니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*