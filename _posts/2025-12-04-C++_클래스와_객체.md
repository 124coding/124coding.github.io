---
layout: single
title:  "C++_클래스와_객체"
categories: study
tags: [c++]
---

# 클래스와 객체
객체 지향 기법은 소프트웨어 설계에 있어서 많은 장점을 제공하는 매우 강력한 기술입니다. 그러나 배우기가 쉽지 많은 않아 언어가 객체 지향을 지원한다고 하여도 프로그래머가 객체 지향을 확실히 이해해야 합니다. 특히 C++는 C언어의 모든 기능을 포함하기에 자칫 잘못하면 절차 지향 방식으로 프로그래밍하기 쉽습니다.  

**절차 지향 프로그래밍(procedural programming)**  
절차 지향 프로그래밍은 프로시저(procedure)를 기반으로 하는 프로그래밍 방법입니다. 프로시저는 일반적으로 함수를 의미합니다. 이렇듯 절차 지향 프로그래밍에서 전체 프로그램은 함수들의 집합으로 이루어집니다. 함수는 입력이 들어오면 출력이 나가는 블랙박스로 간주되며, 절차 지향에서 사용되는 설계 방법은 하향식 설계(top down design)라고도 불립니다. 하향식 설계 방법에서는 문제를 더 작은 서브 프로시저로 분해햐여 원하는 수준에 도달할 때까지 이 과정을 반복함으로 시스템을 설계하는 방법을 말합니다.  

이러한 절차 지향 프로그래밍은 오랫동안 좋은 방법으로 여겨졌지만 데이터와 함수가 분리되지 않는다는 너무나도 큰 단점을 가지고 있기에 많은 프로그래머들이 데이터가 중요한 프로그램의 부분임에도 함수 작성에만 신경을 쓰게 됩니다. 구체적으로는 다음과 같은 문제들이 발생할 수 있습니다.

1. 과도한 전역 변수의 사용  
많은 경우, 데이터는 전역 변수에 저장됩니다. 이 경우, 데이터에 접근하는 것을 통제할 수 없기에 어떤 함수든지 쉽게 그 값을 바꿀 수 있습니다. 일반적으로 규모가 큰 프로그램의 경우, 많은 함수들이 쉽게 접근하게 하기 위해 전역 변수에 핵심적인 데이터를 저장하게 되는데 이러한 전역 변수는 모든 함수에 개방적이기에 값이 언제든 잘못 설정될 가능성이 생기게 됩니다.  

2. 프로그램의 이해가 어렵다.
절차 지향에서는 작업들이 함수로 작성되는데 인간이 동시에 이해할 수 있는 함수의 숫자는 제한되어 있습니다. 따라서 서로 상호작용하는 수백 개의 함수를 이해하는 것은 쉽지 않습니다.  

3. 변경하고 확장하기가 어렵다.
절차 지향의 경우, 프로그램의 복잡도가 어느 정도 이상으로 커지게 되면 프로그램을 변경하기가 어렵기습니다. 종종 하나의 함수를 수정하면 다른 함수들이 영향을 받기 때문입니다.  

**객체 지향 프로그래밍(OOP: object-oriented programming)**  
OOP는 실제 세계가 객체(object)들로 구성되어 있는 것과 비슷하게, 소프트웨어도 객체로 구성하는 방법입니다. 객체 각각은 나름대로의 고유 기능을 수행하면서 다른 객체와 상호작용을 하게 됩니다. 예를 들면 사람이 리모컨으로 티비를 조작한다. 여기서 객체는 사람, 리모컨, 티비를 들 수 있습니다.  

소프트웨어 개발도 이와 같이 하는 방식이 바로 객체 지향입니다. 이후로 연구가 진행될수록 서로 관련된 함수와 데이터를 묶어서 생각해야한다는 점이 명백해졌습니다. 데이터와 함수를 하나의 덩어리(객체)로 묶는 것을 캡슐화(encapsulation)라고 부르며 이러한 객체 지향 프로그래밍은 현재 가장 각광받고 있는 프로그래밍 기술입니다.  

#### **객체의 구성**
객체(object)는 현실 세계에서 존재하는 객체들을 흉내 내어서 소프트웨어 상에서 구현한 것으로 상태와 동작을 가지게 됩니다. 객체의 상태(state)는 객체의 속성으로 예를 들면 원(Circle)에 대한 객체가 존재할 때 반지름, 위치같이 이 원을 정의하는 것들의 모임인 것입니다. 객체의 동작(behavior)은 객체가 취할 수 있는 행동으로 이동하기, 반지름 키우기 등이 이에 해당합니다.  

객체의 상태와 동작은 프로그램에서 변수와 함수로 표현될 수 있으며 즉, 객체는 변수와 함수로 이루어져 있는 코드 묶음이라고 생각할 수 있습니다.  
- 멤버 변수(member variable): 객체 안의 변수에는 객체의 상태를 저장합니다. 객체 안에 포함된 변수를 일반적인 변수와 구별하기 위하여 특별히 멤버 변수 또는 필드(field)라고 합니다.  
- 멤버 함수(member function): 객체 안의 함수는 특정한 동작(작업)을 수행합니다. 이 또한 구별을 위해 멤버 함수 또는 메소드(method)라고 불립니다.  

#### **클래스**
객체 지향 프로그램은 객체로 구성이 된다는 사실을 알았습니다. 그렇다면 같은 종류의 객체는 한개씩만 존재하는 걸까요? 그렇지 않습니다. 위에서 객체의 예를 설명할때 사람, 리모컨, 티비를 예로 들었었는데 이런 객체는 현실 세계에서도 단 한 개 혹은 한 명만 존재하는 것이 아닙니다. 그렇기에 같은 객체들이 여러 개 존재할 수도 있다는 것입니다. 그렇다면 이런 객체들은 어떻게 만들 수 있을까요? 그것은 바로 클래스(class)를 이용하는 것입니다. 클래스란 객체를 만드는 형틀(template) 또는 청사진(blueprint)라고 생각하면 됩니다. 이러한 클래스를 이용하여 만들어지는 객체는 그 클래스의 인스턴스(instance)라고 합니다.  

객체는 생성될 때마다 각 객체에 필요한 기억 공간이 할당됩니다. 각각의 객체에 필요한 공간이란 무엇일까요? 예를 들어 같은 설계도를 이용하여 만든 자동차라고 하더라도 현재 자동차의 속도, 주행 거리, 기어 등의 상태는 다릅니다. 즉, 각기 다른 값을 가질 수 있다는 뜻이고 이들 상태 값을 저장할 공간이 객체마다 필요한 것입니다.  

멤버 함수의 경우에는 같은 클래스에 속하는 객체라면 모두 동일합니다.  

**클래스 작성하기**
```C++
class A{
    int a;
    int b;

    void sum(int x, int y);
}
```

클래스는 다음과 같이 작성할 수 있습니다. 먼저 class 키워드를 이용하여 클래스임을 밝히고 클래스 이름(여기서는 A)을 작성한 후 {} 블록 안에 멤버 변수와 멤버 함수 선언부를 작성하는 것입니다. 이때 멤버 함수 정의는 클래스 외부에서도 가능하고 클래스 내부에서도 가능하지만 관용적으로 긴 함수를 작성할때는 외부에서 작성합니다.  

클래스에는 **접근 지정자**라는 용어가 있습니다. 이는 클래스 외부에서 내부의 변수나 함수를 어디까지 접근할 수 있나를 정의해주는 것입니다. 접근 지정자는 3가지 중 하나로 다음과 같습니다.
- private 멤버는 클래스 안에서만 접근(사용)될 수 있다.
- protected 멤버는 클래스 안과 상속된 클래스에서 접근이 가능하다.(상속은 추후에 학습)
- public 멤버는 어디서나 접근이 가능하다.

```C++
class A{
private:
    int a;
    int b;

protected:
    int c;

public:
    void sum(int x, int y);
}
```

다음과 같이 작성이 되어 있다면 a, b 변수는 클래스 내에선만 c는 상속된 클래스와 현재 클래스만 sum 함수는 어디서든 접근이 가능하다는 의미입니다.  

#### **객체 생성**
이렇게 클래스만 작성되었다고해서 객체가 생성되는 것은 아닙니다. 앞 전에 말씀드렸듯이 이는 객체를 만드는 형틀만 작성한 것입니다. 이제 객체를 만드는 법에 대해 알아보겠습니다. 
객체를 만드는 것은 변수를 선언한다와 똑같이 생각하시면 됩니다.  

```C++
int x; // x 변수 선언
```

위는 x라는 변수를 int 타입으로 선언한 것입니다. 이제 위의 작성된 A 클래스를 이용하여 객체 a를 작성해보겠습니다.  

```C++
A a; // 객체 a 선언
```
이렇듯 클래스 A를 자료형으로 생각하고 a를 변수라고 생각하면 객체를 생성하는 것에 어려움은 없으실 것입니다. 실제로는 컴파일러가 클래스를 사용자-정의 자료형(UDT: user-defined type)이라고 취급하기에 클래스에 특별한 의미를 부여하지는 않습니다.  

위의 문장이 실행되면 a라는 객체가 실제로 생성되어 물리적인 실체를 가집니다. 이처럼 실제로 생성된 객체를 클래스의 인스턴스(instnace)라고도 부릅니다.  

**객체의 멤버 접근**
객체 안에 정의된 멤버 변수와 멤버 함수를 사용하려면 어떻게 해야 할까요? 이것은 도트(.)연산자를 이용하여 접근합니다.  

```C++
a.a;
```

다음과 같이 접근을 하면 됩니다. 그러나 다음 문장은 오류를 발생시킵니다. 왜 그럴까요? 그것은 바로 a가 private 접근 지정자로 정의되어 있기에 이를 클래스 바깥에서 접근하려고 하면 오류가 발생하는 것입니다.  

하나의 클래스에서는 많은 객체가 생성될 수 있습니다. 그렇기에 어떤 객체의 어떤 멤버인지를 확실히 적어주어야 합니다. 객체 지향의 관점에서 보면 클래스안의 멤버 변수를 직접 사용하는 것은 바람직하지 않습니다. 객체 내의 멤버 변수는 간접적으로 접근하는 것이 원칙인데 이는 추후에 더 설명토록 하겠습니다.  

**멤버 함수 중복 정의**  
멤버 함수 또한 일종의 함수이므로 함수 파트에서 설명한 함수 중복 정의가 가능합니다. 그 규칙과 똑같이 매개 변수에 차리을 줌으로 작성을 할 수 있습니다.  

#### **클래스의 인터페이스와 구현의 분리**
C++에서는 멤버 함수를 클래스 외부에 저장할 수 있는 기능이 있다고 했었습니다. 그렇다면 어떤 식으로 작성할 수 있을까요? 먼저 클래스 내부에는 멤버 함수의 원형만 작성해놓습니다. 원형이란 함수 파트에서 설명드렸듯이 함수의 이름과 매개 변수만을 정의하는 것입니다.  

클래스 외부에서 이제 멤버 함수들을 정의하게 되는데 꼭 다음과 같이 작성되어야 합니다.  

```C++
void A::sum(int x, int y){
    ...
}
```

여기서 기본적인 함수와 다른 점은 바로 함수 이름 앞에 "클래스 이름::"을 붙여야 한다는 것입니다. 이것이 바로 함수가 클래스의 멤버 함수임을 나타낸다고 보시면 됩니다.  

이러한 외부 정의와 내부 정의의 차이는 바로 inline이 되는가 안되는가입니다. 내부 정의로 작성된 멤버 함수는 자동적으로 inline 함수가 되어 호출 시 그 코드를 복사해오는 것이고 외부 정의는 기본적인 함수처럼 스택에 인수들을 저장하고 복귀 주소를 지정한 후 멤버 함수로 제어가 이동됩니다.  

**클래스의 선언과 클래스의 정의 분리**
일반적으로 선언(declaration)은 컴파일러에게 식별자에 대한 정보를 주는 것입니다. 반면에 정의(definition)는 식별자가 참조하는 대상을 생성하는 것입니다. 선언과 정의가 동시에 이루어지는 경우도 있고 선언과 정의가 분리되는 경우도 존재합니다.  

예를 들어 다음과 같이 나타낼 수 있습니다.  

```C++
int value; // 선언과 정의가 동시에 이루어진다.
double sqrt(double); // 선언만 주어진다.
```

첫번째 문장은 컴파일러에게 식별자 value의 자료형을 알려주므로 선언이면서 메모리에 변수 value의 공간도 생성하므로 정의에도 해당합니다. 두번째 문장은 식별자 sqrt에 대하여 반환형, 매개 변수 정보만 주어지고 함수 몸체가 주어지지 않았으므로 선언만 된 것입니다.  

클래스에 대해서도 똑같은 이야기를 할 수 있는데 멤버 함수에 대한 정의가 포함되어 있지 않으면 클래스 선언, 멤버 함수에 대한 정의가 포함되어 있으면 클래스 정의라고 할 수 있습니다.  

#### **객체 지향 프로그래밍의 개념들**
여기서는 객체 지향의 중요한 개념들에 대해 살펴보겠습니다.  

**캡슐화**
객체 지향 기술은 많은 이득을 줄 수 있습니다. 지금까지 소프트웨어 개발이 힘들었던 이유는 이전의 다른 프로그래머들이 작성한 수많은 코드가 있음에도 새로운 소프트웨어를 위해 다시 처음부터 모든 것을 개발하여야 한다는 점입니다. 따라서 이전의 코드들을 재사용할 수 있는 체제가 필요하다는 것을 인식하게 되었는데 다른 사람이 작성한 코드 사용을 위해서는 코드 자체가 정리가 잘 되어 있어야 할 것입니다. 즉, 관련된 데이터와 알고리즘이 하나의 묶음으로 정리되어 있어야 합니다. 이것을 캡슐화(encapsulation)이라고 부르며 캡슐화는 용어 그대로 서로 관련된 데이터와 알고리즘을 캡슐에 넣어서 포장한다는 것을 의미합니다.  

앞 전에 같이 학습해온 객체가 바로 하나의 캡슐임을 인지하셨을 것입니다.  

캡슐화에는 총 2가지 목적이 있습니다.  
1. 서로 관련되어 있는 데이터와 알고리즘을 묶는 것  
이렇게 관련된 데이터와 알고리즘을 묶게 된다면 사용이 매우 편리해집니다.  

2. 객체를 캡슐로 싸서 객체의 내부를 보호
이는 객체의 실제 구현 내용을 외부에 감추는 것입니다. 이것을 바로 정보 은닉(information hiding)이라고 합니다. 그렇다면 정보 은닉은 왜 필요한 것일까요? 이는 보안의 문제도 있지만 만약 어떤 프로그래머가 남이 작성한 객체를 사용하고 있었다고 해보겠습니다. 이때 그 프로그래머가 해당 객체의 내부를 다 알아서 마음대로 다 고쳐 사용하였다고 해보겠습니다. 그렇다면 추후 이 객체의 원작자가 이 객체를 업그레이드 시킨다면 프로그래머는 자신이 가지고 있는 그 객체에 업그레이드를 시킬 수 있을까요? 이미 내부 데이터와 메소드가 다 바뀌었기에 이건 불가능할 것 입니다. 그렇기에 이런 일을 방지하고자 정보 은닉이 필요한 것입니다.  

**정보 은닉**  
앞에서 말했듯이 객체의 내부적인 데이터를 직접 조작하지 않는 것이 좋습니다. 프로그램적으로 특정 객체가 다른 객체의 내부적인 데이터에 직접 접근하는 것도 같은 명목으로 좋지 않습니다. 객체 간의 상호 작용은 함수 호출을 통하는 것이 더 좋다는 것입니다. 함수를 가지고만 상호 작용함으로 객체 내부 구현의 세부 사항은 외부 세계로부터 감춰지는 이런 객체의 데이터를 은폐하는 것을 정보 은닉(information-hiding)이라고 합니다.  

그렇다면 정보 은닉은 어떻게 가능할까요? 이것은 앞 전에서 배운 접근 지정자를 이용하면 됩니다. 본인이 은닉되기를 원하는 멤버 변수나 멤버 함수 앞에 private을 붙이면 됩니다.  

**상속**
상속이란 기존의 코드를 재활용하기 위한 기법으로 이미 작성된 클래스(부모 클래스)를 이어받아서 새로운 클래스(자식 클래스)를 생성하는 기법입니다. 자식 클래스는 부모 클래스의 모든 속성과 동작을 물려받습니다. 추가적으로 자식 클래스에만 필요한 필드나 메소드가 있다면 추가 또는 변경도 가능합니다. 상속의 예를 들어보자면 Shape이란 부모 클래스가 있고 그 자식 클래스들로 Rectangle, Triangle 등을 만드는 것입니다.  

**다형성**
다형성이란 객체가 취하는 동작이 상황에 따라 달라지는 것을 의미합니다. C++에서는 서로 다른 자료형에 속하는 객체들이 같은 이름의 멤버 함수에 응답하여서 서로 다른 동작을 보여주는 것이 가능합니다. 객체의 자료형을 미리 알 필요 없고 객체의 정확한 동작은 실행 시간에야 결정됩니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*

