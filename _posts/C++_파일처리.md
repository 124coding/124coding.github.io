# 파일처리
이번에는 C++에서 파일을 어떻게 처리하는지에 대하여 학습하도록 하겠습니다.  

#### **파일 입출력**
입력과 출력은 프로그램에 있어서 중요합니다. 입력이나 출력을 할 수 있어야만 사용자와 상호 대화적(interactive)인 프로그램 작성이 가능합니다. 프로그래머가 입력 장치나 출력 장치의 종류에 따라서 서로 다르게 프로그램을 작성하여야 한다면 아주 불편한 일이 될 것입니다.  

C++에서는 이 문제를 해결하기 위해 스트림(stream)이란 개념을 사용합니다. C++에서의 입력과 출력은 모두 스트림으로 이루어지며 스트림이란 입력과 출력을 바이트(byte)들의 흐름으로 생각하는 것입니다. 프로그램에서 외부로 흘러나가는 연속된 바이트가 출력 스트림이며 입력 스트림은 반대로 외부에서 프로그램으로 흘러들어오는 바이트입니다. 이러한 스트림은 그냥 바이트들이 떠다니는 시냇물이라고 생각하시면 됩니다.  

스트림의 최대 장점은 장치 독립성입니다. 입출력 장치에 상관없이 프로그램을 작성가능합니다. 장치에 상관없이 입력과 출력은 무조건 연속된 바이트의 스트림이라고 생각하면 됩니다.  

**입출력 관련 클래스들**  
다음과 같은 파일 입출력 관련 클래스들이 있습니다.  

```
ofstream: 출력 파일 스트림 클래스, 출력 파일을 생성하고 파일에 데이터를 쓸 때 사용
ifstream: 입력 파일 스트림 클래스, 파일에서 데이터를 읽을 때 사용
fstream: 일반적인 파일 스트림을 나타냄
```

C++에서 파일 처리 수행 시에는 <iostream>과 <fstream> 헤더 파일을 포함시켜야 합니다.  

**파일 쓰기**  
파일에 데이터를 쓸 때 사용되는 스트림은 클래스 ofstream의 객체입니다. 먼저 객체를 나타내는 변수를 선언한 후에 이 변수를 파일과 연결하면 됩니다. 파일에 연결하려면 open() 멤버 함수를 사용하거나 생성자를 사용하면 됩니다.  

```C++
#include <iostream>
#include <fstream>
using namespace std;

int main(){
    ofstream os("example.txt");
    if (!os){
        cerr << "파일 오픈 실패!" << endl;
        exit(1);
    }

    for(int i = 0; i < 100; i++){
        os << i << " ";
    }

    return 0;
    // 객체 os가 범위를 벗어나면 ofstream 소멸자가 파일을 닫는다.
}
```

일단 스트림이 파일과 연결되면 >> 나 << 연산자를 사용하여서 입출력이 가능합니다. 위처럼 파일을 열 때 객체를 사용한다면 객체가 생성되면서 자동으로 파일이 열리고, 객체가 소멸되면서 파일을 자동적으로 닫기에 open이나 close 함수는 호출할 필요가 없게 됩니다.  

코드 작성 시에는 항상 객체 지향적인 방법을 사용하는게 좋습니다. 특히 C++에서는 C 언어의 함수들을 그대로 사용할 수 있기 때문에 open, close를 사용하는 경우도 많습니다. 물론 때에 따라서는 open()이나 close()를 명시적으로 호출해야 하는 경우도 있지만 보통은 객체에게 맡기는 편이 좋습니다.  

**파일 읽기**  
파일을 읽어올 때 사용하는 스트림은 ifstream입니다. 먼저 객체를 나타내는 변수를 선언한 후에 이 변수를 파일과 연결하여 사용합니다. 파일에 연결하려면 open() 멤버 함수를 사용하거나 생성자를 사용하면 됩니다.  

```C++
#include <iostream>
#include <fstream>
using namespace std;

int main(){
    ifstream is("example.txt");
    if (!is){
        cerr << "파일 오픈 실패!" << endl;
        exit(1);
    }

    int number;
    while(is){
        is >> number;
        cout << number << " ";
    }
    cout << endl;

    return 0;
    // 객체 is가 범위를 벗어나면 ifstream 소멸자가 파일을 닫는다.
}
```

**파일 모드**  
ifstream 생성자를 호출할 때 2번쨰 인수로 다음과 같은 것을 넘길 수 있습니다.  

```
ios::in      |      입력을 위하여 파일을 연다.
ios::out     |      출력을 위하여 파일을 연다.
ios::binary  |      이진 파일 입출력을 위하여 파일을 연다.
ios::ate     |      파일의 끝을 초기 위치로 한다.
ios::app     |      파일의 끝에 추가된다.
ios::trunc   |      새로운 내용으로 교체된다.
```

예를 들어 읽기 전용으로 파일을 열려면 다음과 같이 할 수 있습니다.  

```
ifstream is("example.txt", ios::in);
```

이들은 모두 | 연산자를 이용하여 합쳐질 수 있습니다.  

```
ofstream myfile ("example.bin", ios::out | ios::app | ios::binary);
```

#### **멤버 함수를 이용한 입출력**
입출력 연산자인 >> 와 << 을 이용하여서 여러 가지 데이터를 파일에 입출력할 수도 있지만 fstream의 멤버 함수들을 이용하여서 파일에 입출력할 수도 있습니다. 예를 들면 하나의 문자를 읽는 데는 get()을 이용하고 하나의 문자를 출력할 때는 put()을 사용할 수도 있습니다. 파일의 끝에 도달했는지 판단은 eof() 함수를 이용할 수 있습니다.  


```C++
char c;
is.get(c);
while(!is.eof()){
    cout << c;
    is.get(c);
}

cout << endl;
```

위처럼 작성하면 파일에서 한 글자씩 읽어와 화면에 출력하게 됩니다.  

```C++
char c;
while(cin.get(c)){
    os.put(c);
}
```

위처럼 작성하면 사용자로부터 한 글자씩 입력 받아 파일에 작성하게 됩니다.  

**출력 형식 지정**  
콘솔이나 파일에 출력하는 경우에 출력 형식을 지정할 수 있습니다. 예를 들어서 소수점 이하의 자리수를 3개로 하려면 다음과 같은 멤버 함수를 사용합니다.  

```
cout.precision(3);
```

여러 가지의 출력 플래그를 설정하기 위하여 setf()라는 멤버 함수가 제공됩니다. 예를 들어서 고정 소수점 표기법을 사용하고 소수점을 항상 표시하려면 다음과 같은 문장을 사용합니다.  

```
cout.setf(ios::fixed);
cout.setf(ios::show_point);
```

이러한 플래그들은 다양한 종류가 있고 이들은 물론 | 기호를 사용하여 여러 개를 동시 설정할 수도 있습니다.  

출력 필드의 너비 지정 시에는 width() 멤버 함수를 사용합니다.  

```
cout.width(10);
```

다음은 많이 사용되는 플래그들과 그 설명입니다.  

```
ios::fixed: 고정 소수점 표기법 사용
ios::scientific: 과학적 표기법 사용(지수를 사용하여 표기)
ios::showpoint: 소수점을 반드시 표기
ios::showpos: 양수 부호를 반드시 출력
ios::right: 값을 출력할 때 오른쪽 정렬을 사용
ios::left: 값을 출력할 때 왼쪽 정렬을 사용
ios::dec: 값을 출력할 때 10진법을 사용
ios::oct: 값을 출력할 때 8진법을 사용
ios::hex: 값을 출력할 때 16진법을 사용
ios::uppercase: 지수나 16진법으로 표시할 때 대문자를 사용
ios::show: 8진수이면 앞에 0을 붙이고 16진수이면 앞에 0x를 붙인다.
```

플래그 해제 시에는 unsetf() 함수를 사용합니다.  

```
os.unsetf(ios::uppercase);
```

#### **이진 파일**
C++에서는 텍스트 파일(text file)과 이진 파일(binary file)의 두 가지 파일 유형을 지원합니다. 텍스트 파일은 사람이 읽을 수 있는 텍스트가 들어 있는 파일로 소스 파일이나 메모장 파일이 이에 해당합니다.  

반면에 이진 파일은 사람이 읽을 수는 없으나 컴퓨터는 읽을 수 있는 파일입니다. 즉, 문자 데이터가 아니라 이진 데이터가 직접 저장되어 있는 파일입니다. 이진 파일은 텍스트 파일과는 달리 라인들로 분리되지 않습니다. 모든 데이터들은 문자열로 변환되지 않고 입출력됩니다. 그렇기에 라인의 끝을 표시할 필요는 없으며 NULL이나 CR, LF와 같은 문자들은 특별한 의미를 가지지 않고 데이터로 취급됩니다. 이러한 이진 파일은 특정 프로그램에 의해서만 판독이 가능합니다. 이진 파일의 예로는 실행 파일, 사운드 파일, 이미지 파일 등이 있습니다.  

텍스트 파일에서는 모든 정보가 문자열로 변환되어서 파일에 기록됩니다. 즉, 정수값같은 문자열이 아닌 값들도 << 연산자를 통해 문자열로 변환된 후에 파일에 쓰입니다. 파일에서 숫자를 읽을 때도 파일의 문자를 읽어서 입력 연산자 >>가 숫자로 변환하게 됩니다.  

이진 파일은 문자 데이터를 저장하는게 아닌 숫자 데이터가 직접 저장되어 있는 파일입니다. 즉, 정수는 4바이트로 표현되고 이 4바이트가 직접 파일에 써지는 것입니다. 이러한 이진 파일의 필요 이유는 컴퓨터 프로그램이 텍스트 파일에서 숫자 데이터를 읽으려면 먼저 문자를 읽어서 이것을 입력 연산자 >> 을 사용하여 숫자로 변환하는 이러한 과정이 시간이 많이 걸리며 비효율적이기에 효율을 위해 사용하며 텍스트 파일에 비해 저장 공간도 적게 차지하기에 사용됩니다.  

이진 파일의 단점은 당연히 인간이 읽기 힘들다는 것입니다. 문자 데이터가 아니므로 모니터나 프린터로 출력하는 것이 불가능합니다. 또한 텍스트 파일은 컴퓨터의 기종이 달라도 파일을 이동할 수 있습니다. 왜냐하면 아스키 코드로 되어 있기에 다른 컴퓨터에서도 읽을 수 있기 때문입니다. 그러나 이진 파일의 경우 정수나 실수 데이터를 표현하는 방식이 컴퓨터 시스템마다 다를 수 있기에 이식성이 떨어집니다. 따라서 이식성이 중요하다면 조금 효율이 떨어지더라도 텍스트 형식의 파일을 사용하는 것이 좋습니다. 하지만 데이터가 크고 수행 속도가 중요하다면 이진 파일로 하는 것이 좋습니다.  

**이진 파일 입출력**  
이진 파일 입출력을 하려면 open()의 두 번째 인자로 ofstream::binary를 주어서 이진 파일 모드로 파일을 오픈하여야 합니다. write 함수를 사용하여서 변수의 값을 이진 모드로 파일에 씁니다. 읽을 때는 read()함수를 이용합니다.  

```C++
ofstream os( "test.dat", ofstream::binary );
int x = 5;
os.write((char*) &x, sizeof(int));
```

위의 코드는 변수 x의 값을 이진 파일에 작성하는 코드입니다. write에 대해서만 간략히 설명드려 보자면 write의 선언은 다음과 같이 되어 있습니다.  

```
write(const char* s, streamsize n);  
```

const char* s는 데이터를 읽어올 메모리의 시작 주소를 받습니다. 여기가 바이트의 시작점임을 알려주는 것입니다.  
streamsize n은 위 시작 주소로부터 몇 바이트만큼을 읽어서 파일에 쓸 지를 지정합니다.  
이렇기에 어떤 타입이든 혹은 배열이더라도 write를 이용하여 이진 파일에 데이터를 저장하는 것이 가능해집니다.  

이진 파일의 데이터를 읽는 것은 read를 이용합니다.  

```
int x = 0;

ifstream is( "test.dat", ifstream::binary);
is.read((char*) &x, sizeof(int));
```

#### **임의 접근 파일**
지금까지의 파일 입출력 방법은 모두 데이터를 파일의 처음부터 순차적으로 읽거나 기록하는 것이었습니다. 이것을 순차 접근(sequential access) 방법이라고 합니다. 이러한 방법은 한번 읽은 데이터를 다시 읽으려면 현재의 파일을 닫고 파일을 다시 열어야 합니다. 또한 앞부분을 읽지 않고 중간이나 마지막으로 건너 뛸 수도 없습니다. 이러한 불편함을 해결하기 위한 다른 입출력 방법으로 임의 접근(random access) 방법이 있습니다. 임의 접근 방법은 파일의 어느 위치에서든지 읽기와 쓰기가 가능합니다.  

**임의 접근 파일의 원리**  
모든 파일에는 파일 위치 표시자라는 것이 존재합니다. 파일 위치 표시자는 읽기와 쓰기 동작이 현재 어떤 위치에서 이루어지는 지를 나타냅니다. 새 파일이 만들어지게 되면 파일 위치 표시자는 값이 0이고 이것은 파일의 시작 부분을 가리킵니다. 기존의 파일의 경우, 추가 모드에서 열렸을 경우에는 파일의 끝이 되고, 다른 모드인 경우에는 파일의 시작 부분을 가리킵니다.  

파일에서 읽기나 쓰기가 수행되면 파일 위치 표시자가 갱신됩니다. 보통 순차적으로 데이터를 읽게 되면 파일 위치 표시자는 파일의 시작 위치에서 순차적으로 증가하여 파일의 끝으로 이동합니다. 그러나 만약 파일의 데이터를 전체 다 읽지 않고 특정 부분만을 읽고 싶은 경우에는 파일 위치 표시자를 이동시켜서 임의 파일 액세스를 할 수 있습니다. 임의(random)이라는 말은 임의의 위치에서 데이터를 읽을 수도 있다는 의미입니다. 이러한 위치 표시자를 조자하는 함수는 seekg()입니다.  

```
seekg(long offset, seekdir way);
```

여기서 두 번째 매개 변수인 way는 다음과 같은 값들을 가질 수 있습니다.  

```
ios::beg: 처음부터의 offset
ios::cur: 현재 위치부터의 offset
ios::end: 파일의 끝에서부터의 offset
```

사용 예시를 들어보자면 다음과 같이 나타낼 수 있습니다.  

```C++
is.seekg(100, ios::beg); // 처음 위치에서 100바이트 떨어진 곳
is.seekg(0, ios::end); // 파일의 끝
is.seekg(-100, ios::cur); // 현재 위치에서 100바이트 앞으로
```

현재 파일 위치 표시자의 값을 얻으려면 tellg()를 호출하면 됩니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*