---
layout: single
title:  "C++_객체_배열과_벡터"
categories: study
tags: [c++]
---


# 객체 배열과 벡터
다양한 타입을 배열로 만들 수 있듯이 객체 또한 배열로 만들 수 있습니다. 그리고 배열과 지금까지 학습한 배열은 늘 정적이었기에 크기가 결정되고 크기의 변경이 불가능하였습니다. C++에서는 이러한 정적 배열말고 동적 배열인 벡터도 존재하는데 이에 대해 학습하겠습니다. 벡터는 후에 학습할 STL의 한 종류입니다.  

#### **객체 배열**
원을 클래스로 작성하여서 이를 여러 개의 객체로 만들고 싶다고 해보겠습니다. 이미 정의되어 있는 원 클래스를 가지고 객체를 여러 개 만드는건 어렵지 않습니다. 그러나 객체 하나하나에 대해 계속 작성해줘야 한다는 것은 불편하고 비효율적이죠. 이러한 불편을 없애기 위해서 객체 또한 다른 타입들처럼 배열로 만들어줄 수 있습니다.  

```C++
// 객체 배열 선언
클래스_이름 배열_이름[배열_크기];

Circle objArray[3];
```

다음과 같이 Circle 클래스에 대한 크기가 3짜리인 배열이 만들어졌습니다.  
일단 생성이 된다면 배열의 크기는 변경할 수 없습니다. 배열 안에는 객체들이 생성되어 저장되는데 이 때 객체의 기본 생성자가 호출됩니다. 그렇기에 기본 생성자를 정의하지 않으면 오류가 발생할 수 있습니다.  

**객체 배열의 초기화**  
객체 배열 안의 객체들을 서로 다르게 초기화하려면 어떻게 해야 할까요? 그건 바로 각 배열 요소별로 생성자를 호출시키면 됩니다.  

```C++
Circle objArray[10] = {
    Circle(100, 100, 30), // 생성자가 x, y, radius를 받는다고 가정
    Circle(100, 150, 30),
    Circle(100, 200, 30)
}
```

객체 배열은 일반 배열과 같은 초기화 형태를 가지지만 값 대신에 생성자를 호출한다는 차이를 가집니다. 각 배열의 요소마다 다르게 작성한 생성자를 호출할 수도 있습니다.

#### **벡터**
이제까지 학습한 배열은 늘 정적이었기에 컴파일 시간에 배열의 크기가 결정되고 더 이상 크기를 수정할 수 없다는 큰 단점을 가지고 있었습니다. 이러한 배열은 크기 조정이 불가능하기에 배열이 가득 차면 더 이상 필요한 데이터를 더 넣는게 불가능하거나 너무 배열의 크기를 크게 잡아 사용하지 않는 부분이 쓸데없이 메모리를 차지하게 하는 문제가 있을 수도 있는 것이죠.  

그러나 C++에서는 동적 배열(dynamic array)도 제공을 합니다. 이것은 벡터(vector)라고 불리며 라이브러리로 제공됩니다. 이 동적 배열의 장점은 컴파일 시간에 미리 배열의 크기를 결정할 필요가 없다는 것입니다.  

벡터는 템플릿(template)으로 설계되어 있습니다. 템플릿이란 다양한 자료형을 사용할 수 있도록 클래스를 설계하는 기법으로 템플릿으로 작성된 클래스를 사용할 때 원하는 자료형을 지정하여야 합니다.  

벡터는 어떤 자료형이든지 저장할 수 있고 요소가 증가하거나 감소 시 자동으로 크기가 조절됩니다. 벡터는 배열의 특징을 그대로 가지기에 배열의 표기법을 이용하여 임의의 위치에 있는 요소에 빠르게 접근할 수도 있습니다. 요소를 중간에 삽입하거나 삭제 시에는 뒤의 요소들을 모두 이동하여야 하기에 약간의 시간이 걸릴 수 있지만 최근의 컴퓨터들은 충분히 빠르기에 크게 걱정할 부분은 되지 않습니다.  

**벡터의 기초**  
먼저 벡터를 생성하는 방법에 대해서 알아보겠습니다. 다음과 같이 벡터를 작성할 수 있습니다.  

```C++
배열의 자료형 배열의 이름(배열의 크기)

vector<int> scores(10) // <>연산자 안에 벡터 요소들의 자료형이 들어가게 됩니다.
```

템플릿을 사용하는 방법은 간단합니다. 클래스 이름 뒤에 <>를 붙인 후에 <> 안에 원하는 자료형을 기입하는 것입니다.  

벡터도 배열과 마찬가지로 첫 번째 요소의 인덱스는 0이며 마지막 요소의 인덱스는 (크기 - 1)이 됩니다. 배열의 크기 또한 size()를 이용하여 구할 수 있습니다.  

**push_back()과 pop_back()**  
push_back()은 벡터의 가장 뒤에 요소를 하나 추가하는 벡터의 멤버 함수로 이는 벡터의 크기를 1 늘리고 그 위치에 멤버 함수에 입력한 값을 추가하게 됩니다. pop_back()은 반대로 가장 뒤의 값을 빼오면서 벡터의 크기를 1 줄이는 벡터의 멤버 함수입니다.  

벡터의 처음은 begin()이나 front() 함수로 벡터의 끝은 end()와 back()으로 알 수 있습니다.  

```C++
scores.begin();
scores.front();
scores.end();
scores.back();

scores.push_back(10);
scores.pop_back();
```

**벡터에서 요소의 위치**  
벡터에서 요소의 위치는 반복자(iterator)를 이용하여 표시합니다. 예를 들어 begin()과 end()는 반복자로써 벡터의 시작과 끝을 식별합니다. begin()으로 식별되는 요소는 시퀀스의 일부이지만 end()는 시퀀스의 끝을 하나 넘는 요소를 가리킨다.  

반복자는 일반화된 포인터라고 생각하면 됩니다. 포인터는 추후에 학습할 것입니다.  
모든 요소에 접근하는 반복자는 다음과 같이 작성할 수 있습니다.  

```C+
for(auto p = scores.begin(); p != scores.end(); p++){
    ...
}
```

이 때 반복자를 통해 요소의 값을 얻을려면 *p를 이용하면 됩니다. 반복자가 중요한 것은 벡터 안의 요소들을 가리킬 수 있기 때문으로 STL 알고리즘을 적용할 때는 반복자를 사용하여야 합니다.  

**중간에서 삭제하는 방법**  
중간에서 삭제하려면 삭제하려는 요소의 인덱스를 알아야 합니다. 만약 원하는 인덱스가 i라고 한다면 다음과 같은 문장으로 i번째 요소를 삭제할 수 있습니다.  

```C++
scores.erase(scores.begin() + i);
```

**벡터와 연산자**  
벡터에는 편리성을 위하여 연산자들이 중복 정의되어 있습니다. 대입 연산자(=)를 이용하면 하나의 벡터를 다른 벡터로 복사할 수 있습니다. 기존의 배열에서는 하나의 배열을 다른 배열로 대입 연산자를 이용하여 복사할 수 없습니다. 벡터와 벡턴를 비교할 때도 ==나 != 연산자를 사용할 수 있습니다. ==에서 벡터의 요소의 개수와 값이 모두 일치할 때만 true를 반환합니다.  

#### **array 클래스**
앞의 벡터에서는 크기를 미리 결정하지 않아도 된다는 장점이 있었습니다. 그러나 벡터는 생성과 소멸을 하는데 상당한 시간이 소요되게 되어 이러한 성능 문제로 기존의 배열을 사용하는 경우도 많습니다. 이러한 문제를 해결하기 위해 array 클래스가 사용되기 시작했습니다. 이 array 클래스는 벡터의 장점과 기존 배열의 성능을 동시에 누릴 수 있습니다.

```C++
array<int, 3> list {1, 2, 3};
```

다음은 array를 이용하여 크기가 3인 배열을 선언과 동시에 초기화한 것으로 다음과 같은 다양한 멤버 함수를 가져 벡터와 같이 편리한 함수들을 제공한다는 장점이 있습니다.  

- size(): 배열의 크기
- fill(): 배열의 모든 원소를 동일한 값으로 채운다.
- empty(): 배열이 비었는지 검사
- at(): 배열 요소 접근에 사용 ([]와 같다)
- front(): 배열의 첫 번째 요소
- end(): 배열의 마지막 요소

그렇다고 array 클래스가 크기를 동적으로 변경할 수 있는 것은 아니기에 동적 배열이 필요하다면 벡터를 사용해야 합니다.
________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*


