---
layout: single
title:  "WindowAPI를_이용한_탄막게임_ii_기본"
categories: development
---

# 객체 이동
객체의 이동에 대해 먼저 설명드리겠습니다.  
먼저 앞선 포스팅에서 벡터에 대해 설명드린 적이 있습니다.  
이제 객체의 이동은 이 벡터를 이용하게 됩니다. 먼저 현재 위치에서 자신이 이동할 방향을 단위 벡터로써 설정해놓고 그 방향으로 작성된 속도에 맞게 나아가게 되는 것입니다.   
이것에 대한 부분은 제 코드에서 더 상세하게 살펴볼 수 있으실 것입니다.  

플레이어의 이동은 앞선 포스팅의 Hash 구조를 이용하여 키를 지정하고 그 방향에 맞게 단위 벡터를 두고 속도를 조절하는 것입니다.  
그렇다면 탄환 발사는 어떻게 구현할 수 있을까요?

## 탄환 발사
탄환 발사 또한 마찬가지입니다. 먼저 원하는 키에 발사에 관련된 함수를 할당해주고 그 키가 눌릴때마다 함수를 불러주는 것입니다.  
이때 탄환의 움직임 또한 마찬가지로 속도를 조절하여 구현하게 됩니다.  

# 키 입력
그렇다면 키 입력은 언제 일어나게 될까요? 자 이게 무슨 말이냐. 키 입력에는 크게 3가지의 상태를 가지게 됩니다.  

첫째, 키를 누르는 순간  
둘째, 키를 누르고 있는 중  
셋째, 키를 떼는 순간  

프로그래머는 이것을 자신이 원하는 동작을 수행할 수 있게 설정해두어야 합니다.  
예를 들면 탄환 발사 시에 키를 누르는 순간 한번만 발사? 키를 누르는 중에는 계속 발사? 키를 떼는 순간 발사? 이런 것들을 설정해주어야 한다는 것입니다.  

간단하게만 보이게 되면  
```C++
for (auto t = mMapKeyInfos.begin(); t != mMapKeyInfos.end(); ++t)
{
	int tPushCount = 0;

	if (GetAsyncKeyState(t->second->mKeyInput) & 0x8000) {
		++tPushCount;
	}

	if (1 == tPushCount )
	{
		if (!t->second->mIsDown && !t->second->mIsPress) {
			t->second->mIsDown = true;
		}
		else if (t->second->mIsDown && !t->second->mIsPress) {
			t->second->mIsDown = false;
			t->second->mIsPress = true;
		}
	}
	else
	{			
		if (t->second->mIsDown || t->second->mIsPress ) {
			t->second->mIsDown = false;
			t->second->mIsPress = false;
			t->second->mIsUp = true;
		}
		else if (t->second->mIsUp) {
			t->second->mIsUp = false;
		}
	}
}
```

다음과 같이 상태들을 설정할 수 있습니다. 더 자세한 코드들은 제 코드에서 확인할 수 있습니다.  

# 유도탄
유도탄은 위에서 말한 객체 이동에서 단위 벡터로 방향을 잡아준다고 한 적 있었는데 그것을 프레임마다 시행해주면 됩니다.  

# 각도
게임 프로그래밍에서는 좌표 못지 않게 각도 또한 중요합니다.  
**각도의 종류**  
1. 도(degree):  
   1바퀴를 360등분한 것중에 하나를 1도라고 칭한 것.

2. 라디안(radian):  
   반지름이 r인 원의 호의 길이 r을 1라디안이라고 칭한 것.

라디안은 원의 정의로부터 끌어낸 각도의 개념으로 실수의 연산체계에 부합되는 각도의 개념입니다.  
그러므로 수학함수들 내부에서는 각도 연산에 라디안을 사용하게 됩니다.  

# 충돌 관리
여기선 가장 단순한 원과 원의 충돌에 대해서만 설명하겠습니다.  
다양한 충돌 알고리즘들이 존재하지만 원과 원의 충돌은 가장 연산량이 적습니다. 그 이유는 반지름만 충돌에 관여하게 되므로 글에 대한 계산만 해주면 되기 때문입니다.  

이러한 방법으로는 각 원의 반지름은 이미 알고 있기 때문에 각 원의 반지름의 합이 각 원의 중심점끼리의 거리보다 크게 된다면 충돌로 판단할 수 있게 되는 것입니다.  

두 점 사이의 거리를 구하는 공식은 2가지가 있습니다.  
1. route((Ax - Bx)^2 + (Ay - By)^2)
2. route(Dot((Ax - Bx),(Ay - By)))

여기서 1번째 방법은 흔한 점 A에서 점 B를 빼서 각 성분 제곱 후 제곱근을 하는 것이고 2번째 방법은 점 A에서 점 B를 빼서 내적 후 제곱근을 취하는 것입니다.  

여기서 자기 자신을 내적한 것은 노름의 제곱과 같다는 성질을 이용한 것으로 코드 상에서 구현하기 쉽기 때문에 이 방법이 유용하게 이용되고 있습니다.  

-----------------------
### 더 다양한 내용들이 있지만 기본에 대해서는 여기까지만 작성하도록 하겠습니다.  
### 제가 수업을 들으며 내용을 다시 상기시키기 위해 작성하는 것으로 미처 오류를 범하는 부분이 있을 수도 있습니다.  