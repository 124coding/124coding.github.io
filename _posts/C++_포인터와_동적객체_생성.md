# 포인터와 동적객체 생성
이번에는 앞 전에서 설명하지 않고 넘어갔던 포인터와 객체의 동적 생성에 대해서 학습하도록 하겠습니다.  

#### **포인터**
컴퓨터 메모리는 여러 개의 바이트로 구성되어 있으며 각 바이트마다 0부터 시작하는 주소가 붙여져 있습니다. 변수는 이러한 컴퓨터 메모리에 이름을 붙여서 참조하는 것입니다. 변수를 사용하면 프로그래머가 특별히 컴퓨터 메모리의 주소에 대하여 신경 쓸 필요가 없습니다. 혹시 메모리가 필요하다면 변수를 생성하여 사용하면 됩니다. 하지만 장치 드라이버나 동적 메모리 할당에서는 메모리를 주소로 참조해야 하는 경우가 발생하는데 바로 이 때 포인터(pointer)가 사용됩니다. 포인터는 가리킨다는 뜻이 동사 point에 er을 붙인 것으로 따라서 무언가를 가리키는 변수로 포인터에는 메모리의 주소가 저장됩니다. 포인터는 * 연산자를 이용하여 선언합니다.  

```C++
int* p;
```

위의 코드에서 포인터 p는 int형을 가리키는 포인터로 선언되었습니다. 포인터 생성 직후에는 아직 초기화 되어 있지 않기에 사용하기 전에는 반드시 초기화가 필요합니다. 이때 포인터 타입과 변수의 타입은 일치하여야 합니다.  

#### **주소 연산자 &**
C++에서는 변수의 주소를 계산하는 연산자 & (주소 연산자)가 있습니다. 참조자에 대해서 설명할때 같은 기호를 사용하였는데 그것과 이것은 다름을 알고 있어야 합니다.  

```C++
p = &number;
```

간단하게 예제를 작성해보면 다음과 같습니다.  

```C++
int number = 10;
int *p;

p = &number; // number 변수의 주소를 p가 값으로 가지게 된다.
```

위의 코드를 상황적으로 설명해보자면 (number: 10 -> number의 주소: 1008(임의)) 다음과 같은 number가 정의되었다고 할때 &number(number의 주소): 1008을 포인터 p에게 값으로 주어 p는 1008이라는 주소를 갖고 있는 것입니다. 즉 p는 number를 가리키고 있는 것이 됩니다.  

#### **간접 참조 연산자** *
포인터가 단순히 메모리의 주소만 가리키는 것이라면 큰 의미를 가지지 않을 것입니다. 포인터가 유용한 이유는 포인터가 가리키는 메모리 공간의 값을 읽어오거나 변경이 가능하기 때문입니다. 포인터 p가 가리키는 메모리 공간의 내용을 가져오려면 *p라고 작성하면 됩니다. 이것을 포인터를 통한 간접 참조(dereferencing, indirection)이라고 합니다.  

```C++
cout << *p; // 10을 출력
```

#### **nullptr**
만약 포인터가 선언만 되고 초기화되지 않았다면 임의의 주소를 가리키게 되고 이것은 문제가 되는 상황이라고 볼 수 있습니다. 그렇기에 아직 포인터가 아무것도 가리키고 있지 않다면 nullptr로 초기화해주는 것이 바람직합니다.  

```C++
int *p = nullptr;
```

#### **동적 할당 메모리**
동적 메모리 할당(dynamic memory allocation)이란 프로그램이 실행 도중에 동적으로 메모리를 할당받는 것을 말합니다. 컴퓨터는 아직 사용하지 않은 메모리 공간을 관리하고 있는데 이것을 히프(heap)라고 합니다. 동적 메모리는 이 히프에서 할당받는 메모리입니다.  

동적 할당 메모리를 이용하면 필요한 때에 필요한 만큼만 할당 받을 수 있기 때문에 메모리를 매우 효율적으로 사용할 수 있습니다. 이러한 동적 할당 메모리는 사용이 끝나면 반드시 운영 체제에게 반납하는 단계가 필요하며 만약 반납하지 않으면 다른 프로그램이 동적 메모리를 사용할 수 없게 될 것이기에 메모리 자원 측면에서 큰 손실을 발생시킬 수 있습니다. 이러한 동적 메모리는 포인터 말고는 접근할 수 있는 방법이 없습니다.  

#### **new와 delete**
동적 메모리 사용은 이제 모든 프로그래밍 언어에서 일반화가 되었기에 C++에서는 new와 delete라고 하는 별도의 연산자를 제공합니다. 

동적 메모리는 new 연산자를 이용하여서 할당합니다. new 뒤에는 자료형을 적습니다. 만약 하나 이상의 요소를 필요로 한다면 [] 안에 요수의 숫자를 적습니다. new 연산자는 할당되는 동적 메모리의 시작 주소를 반환합니다.  

```C++
p = new T;
p = new T[N];
p = new T[N] {a, b, c, ...};
```

첫 번째 문법은 T 타입의 변수 하나를 저장할 수 있는 공간을 할당합니다. 두 번째 문법은 T 타입의 배열을 할당합니다. 세 번째 문법은 할당되는 배열의 초기값을 지정합니다.  

이때 배열에 대한 포인터에 관해 p가 가리키는 첫 번째 변수는 p[0] 또는 *p로 접근할 수 있고 두 번째 변수는 p[1] 또는 *(p + 1)로 접근할 수 있습니다.  

정적 배열과 동적 배열은 어떤 차이점이 있을까요? 앞 전에도 말씀드렸듯이 정적 배열은 컴파일 시에 크기가 결정되는 반면 동적 배열은 new에 의하여 생성되는데 그 크기를 변경할 수 있습니다. 동적 배열은 컴퓨터 시스템에 의하여 히프 메모리 영역에 할당됩니다. 메모리는 한정된 자원이기 때문에 동적 메모리 할당 요청은 항상 만족되지 않습니다. 요청한 메모리가 없는 경우에 bad_alloc이라는 오류(exception)가 발생합니다.  

동적 메모리는 사용이 끝나면 반드시 해제하여야 하며 동적 메모리를 해제하려면 delete 키워드를 사용하여야 합니다.  

```C++
delete p;
delete[] p;
```

동적 할당받은 메모리 공간을 반납하려면 위의 문장을 사용하면 됩니다. 주의할 점으로는 만약 요소의 숫자를 받는 즉, 배열의 포인터에 대해서는 delete[]를 사용하여야 합니다. delete만 사용하면 오류가 생기게 됩니다.  

#### **스마트 포인터**
최신 C++에는 스마트 포인터(smart pointer)가 포함되어 있습니다. 포인터를 사용하면 반드시 동적 메모리를 삭제하여야 합니다. 삭제하지 않으면 누수가 생기기 때문입니다. 자바나 C#은 쓰레기 수집기 즉, 가비지 콜렉터가 있어서 자동으로 동적 메모리가 수집되어 삭제됩니다. 최신 C++에는 이러한 수동 제거라는 불편함을 줄이기 위해 스마트 포인터 기능이 포함됩니다. 스마트 포인터를 사용하면 프로그래머가 동적 메모리 할당 후 이 메모리에 대해 잊어버려도 자동으로 동적 메모리가 삭제되어 버그를 줄일 수 있다는 장점이 있으며 스마트 포인터는 자동으로 nullptr로 초기화됩니다.  

```C++
unique_ptr<int> p(new int);
unique_ptr<int[]> buf(new int[10]);
```

#### **객체의 동적 생성**
앞에서 new와 delete를 사용하여 동적으로 변수나 배열을 생성하여 보았습니다. 그렇다면 객체도 new와 delete를 사용하여 동적으로 생성 가능할까요? 물론입니다. 어떤 경우에는 객체를 동적으로 생성하는 것이 객체 지향 관점에서 바람직합니다. 가끔은 객체가 몇 개나 생성되어야 하는지 알 수 없는 경우가 종종 있기 때문입니다. 예를 들면 온라인 게임에서 사용자가 몇 명이나 접속할지 등은 알 수 없기 때문입니다. 

```C++
Car* p = new Car;

delete p;
```

위와 같이 객체를 생성하면 클래스의 기본 생성자가 호출됩니다.

#### **포인터를 통하여 멤버 접근하기**
동적으로 생성된 객체의 멤버에 접근하기 위해서는 도트 연산자(.)를 사용하면 됩니다. 

```C++
(*p).getVelocity();
```

다음과 같이 사용하게 되면 *를 붙였기에 p를 가리키는 것 즉, Car 객체가 됩니다. 객체 안의 getVelocity() 함수를 사용할 수 있는 것입니다. 이때 괄호를 붙인 이유는 * 연산자 적용 후 도트 연산자를 적용해야 하기 때문입니다. 이러한 표기법은 좀 번거롭게 느껴집니다. 그렇기에 C++에서는 다른 연산자를 이용할 수도 있습니다.  

```C++
p->getVelocity();
```

다음과 같이 -> 연산자를 이용하면 * 와 . 연산자를 이용하지 않아도 됩니다.  

이렇게 객체를 동적으로 생성하면 히프에 해당 객체가 생성되는 것입니다.  

#### **멤버도 동적 생성하기**
클래스의 멤버들 히프에 동적으로 생성할 수 있습니다. 이럴 경우에 생성자에서 동적 할당되어야 하고 소멸자에서 동적 메모리를 해제하여야 합니다. 앞 전에서 소멸자 개념을 배울때 넌지시 말씀드린 적이 있습니다.  

```C++
class Car{
    int* velocity;

public:
    Car(){
        velocity = new int;
    }

    ~Car(){
        delete velocity;
    }

    int getVelocity() {
        return *(this->velocity); // 좀 더 안전한 연산을 위해 괄호 사용
    }

    void setVelocity(int v) {
        *(this->velocity) = v;
    }
};

int main() {
	Car* c = new Car();

    c->setVelocity(10);

    cout << c->getVelocity();

    delete c;

	return 0;
}
```

위처럼 클래스 안의 멤버 변수 velocity를 생성자에서 동적 할당하고 디폴트 값으로 설정합니다. 소멸자에서는 동적 할당된 메모리를 삭제합니다. 소멸자이기에 이들 포인터를 nullptr할 필요는 없습니다.  

메모리 관리는 전적으로 클래스 구현 안에 감추어지기에 main은 이전과 동일하게 멤버 함수들을 호출합니다. 여기서 ~Car() 즉, 소멸자의 역할은 중요합니다. 만약 소멸자를 작성하지 않았다면 기본 소멸자가 불려질텐데 기본 소멸자에는 delete velocity; 문장이 포함되어 있지 않기에 동적 할당된 메모리가 계속 히프에 남아있게 되는 누수가 일어날 것이기 때문입니다.  

#### **this 포인터**
제가 앞 전의 예제 코드들에서 계속 사용해왔던 this에 대해 학습하겠습니다. 모든 클래스 멤버들은 숨어 있는 하나의 매개 변수를 가지고 있습니다. 바로 this 포인터로 이 포인터는 함수가 실행되는 객체를 가리킵니다. 이 포인터의 목적은 말 그대로 함수를 호출하고 있는 객체를 알려주는 것입니다. 일반적으로는 몰라도 문제가 되지 않지만 가끔 객체 자체를 참조하는 것이 필요해집니다. 예를 들면 현재 객체를 반환할 필요도 생기는데 이때 this 포인터가 이용되는 것입니다.  

꼭 멤버를 참조할 때 this를 사용하지 않아도 됩니다. 그러나 저같은 경우에는 this를 사용하는 것이 습관이 되어서 사용하고 있습니다.  

#### **const 포인터**
const 키워드는 포인터 앞이나 뒤에 사용할 수 있습니다. 예를 들어서 다음과 같은 것은 모두 올바르게 사용된 것입니다.  

```C++
const int *p1;
int* const p2;
const int* const p3;
```

그렇다면 의미적으로도 같을까요? 그건 아닙니다 이 3개의 문장은 모두 의미가 다릅니다. p1은 변경되지 않는 정수를 가리키는 포인터입니다. 이 포인터를 통하여 참조되는 값을 변경하는 것은 불가능하단 것입니다.  

p2는 정수에 대한 상수 포인터입니다. 정수는 변경될 수 있지만 p2는 다른 것을 가리킬 수 없다는 의미로 상수 포인터는 재할당이 불가합니다.  

p3는 상수에 대한 상수 포인터로 포인터가 가리키는 값도 포인터가 다른 것을 가리키게 하는 것도 불가능하단 뜻입니다.  

만약 멤버 함수를 const로 정의하면 함수 안에서 멤버 변수를 변경하는 것이 금지됩니다. const 객체를 가리키는 포인터를 정의하면 이 포인터로 호출할 수 있는 함수는 const 함수뿐입니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*