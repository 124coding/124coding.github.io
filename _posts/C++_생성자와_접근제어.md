# 생성자와 접근 제어
#### **생성자**
변수의 경우, 초기화를 해주지 않으면 쓰레기값을 가지는 경우가 종종 있습니다. 객체도 마찬가지로 초기화하지 않으면 쓰레기 값을 가지게 됩니다. 그렇기에 객체 또한 생성 후 반드시 초기화해야 합니다. 객체의 초기화에는 멤버 변수의 값 초기화뿐만 아니라 객체의 동작에 필요한 메모리 공간이나 기타 자원들을 할당하는 것도 포함됩니다.  

C++에서는 객체 초기화를 담당하는 생성자(constructor)라는 특수 함수가 존재합니다.  

**생성자는 왜 필요한가?**  
객체를 초기화할때 늘 객체를 생성하고 외부적으로 따로 값을 넣어주는 것은 굉장히 불편하고 비효율적입니다. 그렇기에 객체를 생성할 때 객체를 초기화하는 함수가 자동으로 호출된다면 매우 편리할 것입니다.  

생성자는 다음과 같이 클래스 이름과 똑같은 멤버 함수로 객체를 초기화하는데 사용됩니다. 인수가 있는 생성자가 정의되어 있는데 프로그래머가 객체 생성 시 그 인수에 값을 주지 않으면 오류가 발생합니다. 이를 방지하기 위해서 생성자에도 디폴트 인수를 넣어줄 수 있으며 생성자 또한 함수이기에 중복 함수가 가능합니다.  
```C++
class Time{
    int hour;
    int minute;

public:
    Time(int h, int m){
        // this는 현재 객체를 의미하는 것이다.
        this->hour = h;
        this->minute = m;
    }
}
```

위처럼 클래스가 작성되어 있다고 하고 객체를 생성할 때 생성자를 부르는 방법은 다음 3가지가 있습니다.  

```C++
Time a(10, 25);
Time c {10, 25};
Time d = {10, 25};
```

이때 저런 식으로 인수가 있는 생성자가 있는데 다음과 같이 작성하면 오류가 발생합니다.  

```C++
Time d; // 오류 발생
```

그러나 만약 기본 생성자가 있다면 오류가 발생하지 않습니다. 기본 생성자는 아무 인수도 받지 않는 생성자로 생성자를 따로 정의하지 않으면 자동으로 컴파일러가 만들어주지만 위처럼 생성자가 따로 있다면 프로그래머가 따로 작성해주어야 합니다.  

**멤버 초기화 리스트**
C++에서는 생성자를 좀 더 쉽게 작성할 수 있는 방법이 있습니다. 위의 Time 생성자를 변형해서 표현하면 다음과 같습니다.  

```C++
Time(int h, int m) : hour(h), minute(m){

}
```

이것을 초기화 리스트(initializer list)라고 부릅니다. hour(h)는 멤버 변수 hour를 h로 초기화한다는 의미입니다. 이는 프로그래머의 취향으로 마음에 드는 대로 작성해도 아무 문제 없습니다.  

#### **소멸자**
객체가 생성될 때 생성자가 있다면 소멸될 때는 소멸자(destructor)가 있습니다.  
생성된 객체가 범위를 벗어나면 객체는 소멸됩니다. 이때마다 호출되는 특정한 멤버 함수가 소멸자로 클래스 이름에 물결표(~) 접두사를 붙여서 작성합니다. 소멸자는 파일을 닫거나 메모리를 반환하는 작업과 같이 프로그램을 종료하기 전에 자원을 반납하는데 매우 유용하게 사용됩니다.  

```C++
class Time{
    int hour;
    int minute;

public:
    Time(int h, int m){
        this->hour = h;
        this->minute = m;
    }
    ~Time(){} // 여기서는 포인터같은 동적 메모리를 받는게 없기에 소멸자가 따로 일을 하진 않는다.
}
```

#### **접근 제어**
접근 제어(access control)란 외부에서 특정한 멤버 변수나 멤버 함수에 접근하는 것을 제어하는 것입니다. 앞 전에서 학습한 접근 지정자 중 private으로 모든 멤버 변수를 작성했다면 외부 접근은 완전히 제한되는 것일까요? 그렇진 않습니다. 그렇게 된다면 객체끼리의 상호작용을 완전히 틀어막는 것이기 때문입니다. C++에서는 클래스 작성 시 접근 지정자가 생략되면 자동으로 private으로 작성하게 됩니다.  

그렇다면 어떤 식으로 private인 멤버 변수에 접근할 수 있을까요? 바로 접근자와 설정자를 이용하는 것입니다.  

**접근자와 설정자**  
앞에서 Time 클래스 안에 정의된 hour 변수와 minute 변수를 밖에서 읽지 못하게 하였지만 접근자(getter)와 설정자(setter)라는 함수를 제공하여 외부에서 안전하게 멤버 변수들을 읽거나 변경할 수 있도록 할 수 있습니다. 이는 다음과 같이 작성할 수 있습니다.  

```C++
class Time{
    int hour;
    int minute;

public:
    Time(int h, int m){
        this->hour = h;
        this->minute = m;
    }
    ~Time(){}

    // hour, minute에 대한 접근자와 설정자
    int getHour() { return this->hour; }
    void getHour(int h) { this->hour = h; }
    int getMinute() { return this->minute; }
    void getMinute(int m) { this->minute = m; }
}
```

접근자 앞에는 변수명에다가 get, 설정자 앞에는 set을 붙이는게 불문율로 사용되고 있습니다. 이러한 설정자를 사용함으로 잘못된 값이 넘어오는걸 사전에 방지하는 것도 가능합니다. 또한 접근자는 반환하는 데이터의 형식을 제어가능하기에 외부 코드가 실제 데이터 표현 방식을 모르게 하는 것도 가능합니다.  

#### **객체와 함수**
객체와 함수와의 관계를 살펴보겠습니다.  

- **객체가 함수의 매개 변수로 전달되는 경우**  
함수의 인수는 기본적으로 값에 의하여 매개 변수로 전달됩니다. 이것은 인수가 객체일때도 마찬가지입니다.  
값에 의하여 매개 변수로 전달한다고 하였기에 함수 내부에서 인수에 대해 변형을 이리저리 진행하여도 외부의 본 객체에게는 아무런 변화도 일어나지 않는 것입니다. 이러한 방법의 장점으로는 안전하다는 것입니다. 말했듯이 함수 내부에서 객체가 막 바뀌어도 외부의 본 객체는 변화가 없기 때문입니다. 그러나 단점으로는 객체를 그대로 하나 복제해서 사용하는 것이기에 객체가 크면 클수록 시간이 오래 걸릴 수 있습니다.  

- **객체의 참조자가 함수의 매개 변수로 전달되는 경우**  
참조자란 변수에다가 하나의 이름을 더 주는 것이라고 했었습니다. 참조자는 & 기호를 이용하여 정의합니다. 따라서 함수 내부 객체를 변형시키면 외부 원본 객체도 변형이 일어난다는 것입니다. 이는 원본 객체가 변형이 일어나기에 사용에 주의를 주어야 합니다. 그러나 속도가 기본 값에 의한 방법처럼 복제가 없기에 더 빠르다는 장점이 있습니다.  

- **함수가 객체를 반환하는 경우**
함수가 객체를 반환하는 경우에도 객체의 내용이 복사될 뿐 원본이 전달되지는 않습니다.  

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*