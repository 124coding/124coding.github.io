---
layout: single
title:  "WindowAPI를_이용한_탄막게임_i_기본"
categories: development
---

# 기본적인 소개
이는 제가 다니고 있는 SBS아카데미에서의 과제를 제 입맛에 맞게 수정한 것입니다.  
기본적으로 수업을 들으며 작성된 부분들에 대해서만 여기서 간단하게 설명을 하고 제가 직접 구현한 것들은 어떤 것들이 사용되었는지 등을 같이 설명하기 위해 다음 포스팅들에 작성하겠습니다.  
<br/>

# WindowAPI 프로그래밍 소개
Window API 프로그래밍이란 윈도우즈 운영체제에서 응용 프로그램 (Application)을 만들기 위해 윈도우 운영체제의 함수들을 이용하여 프로그래밍을 하는 것을 말합니다.  
즉, 이는 운영체제와 직접적으로 관련이 있는 프로그램이라고 생각할 수 있습니다.  

이러한 WindowAPI의 기본 베이스는 **메시지**를 이용하는 것입니다.  

Windows API는 베이스 소스는 콘솔에서 했던 소스들과 전혀 다르게, WinMain이란 것을 사용하며 상당히 소스가 긴게 특징입니다.  

## 자주 사용하는 용어들
1. 핸들(Handle): 오브젝트에 대응하는 겹치지 않는 값.
2. 인스턴스(Instance): 클래스가 메모리에 실제로 구현된 실체 즉, 실행된 프로그램
3. 핸들 인스턴스(HandleInstance, HInstance): 프로그램 코드를 담고 있는 모듈에 대한 핸들, 현재 실행중인 인스턴스에 관한 정보를 터득 가능
4. 핸들 윈도우(HandleWindow, HWND): 현재 윈도우의 핸들을 가져옵니다. (핸들 인스턴스는 핸들 윈도우를 부를 수 있지만 핸들 윈도우는 핸들 인스턴스를 못 부름. 핸들 인스턴스가 더 상위 객체)
5. 윈도우(WND, Window)
6. 메시지(Message, MSG)

여기서 왜 핸들에 값을 부여했는가 하면, OS는 오브젝트를 생성한 후 중복되지 않는 정수형의 ID를 핸들값으로써 부여한 후 프로세서에 넘김으로 오브젝트의 안전성을 확보하고 이 핸들을 받아 생성된 오브젝트를 아무데서나 자유롭게 참조할 수 있게 만들어 놓은 것입니다.(C의 포인터 같은 역할)

## WindowAPI 프로그래밍 기본 구조
여기서는 정말 간단하게만 설명할 것이기에 더 궁금한 부분은 따로 찾아보는게 도움이 되실겁니다.  
윈도우 프로그램의 기본 프로그램 구조는 크게 다음의 두가지로 나뉩니다.  
1. 윈도우를 만들고 시동을 거는 부분  
2. 메시지를 처리하는 부분  

**WinMain()**  
윈도우 클래스(윈도우의 공통된 데이터)를 만들고 등록합니다.  
실제 눈에 보이는 윈도우를 생성합니다.  

**기본 메시지 루프**  
메시지 큐에서 메시지를 가져와 메시지를 해석하고 윈도우 프로시저로 전달합니다.  

**WndProc()**  
전달된 메시지의 종류에 따라 임의의 처리를 수행합니다.

이것이 기본 구조로 메시지를 메시지큐에 전달하면 메시지를 순서대로 WndProc가 처리하는 것입니다.

이때 WindowAPI에서 메시지를 받는 기본적으로 정의된 함수는 GetMessage입니다. 이 함수는 메시지큐에서 메시지를 하나씩 가져오는 함수로 특징으로는 동기(Sync)이며 블럭(Block)입니다. 이것은 제가 공부하고 만드는 게임프로그래밍에는 적합하지 핞게 됩니다.  

그 이유가 바로 동기이며 블럭이라는 함수의 특징 때문입니다. 이러한 특징은 메시지가 없다면 메시지가 있을때까지 프로그램이 대기상태에 들어가게 되고 그렇다면 프로그램의 실행의 흐름이 멈춰서 전체적인 게임이 멈춘 것처럼 보이게 되기 때문입니다.  

이를 해결하기 위해 메시지를 받는 함수는 PeekMessage를 쓰게 됩니다. 이는 비동기(ASync)이며 넌블럭(Non-Block)이라는 특징을 가지고 있어 게임 프로그래밍에 적합합니다.  

이렇게 간단하게만 WindowAPI에 대해 설명하고 넘어가도록 하겠습니다.  
<br/>

# 좌표계
게임 프로그래밍에서 중요한 것은 좌표입니다.  
게임에서 보이는 텍스쳐들, 오브젝트들의 위치 등을 설정할 때 좌표가 중요하기 때문입니다.  

여기서는 데카르트 좌표계와 윈도우 좌표계에 대해 설명하겠습니다.  
1. 데카르트 좌표계:  
   가장 널리 알려진 좌표계로, 학교 수학 시간에 배우는 그 좌표계입니다.  
   이는 서로 직교하는 x축(수평)과 y축(수평)으로 이루어집니다. 이 때 두 축이 만나는 지점을 원점(Origin, 0, 0)이라고 합니다. 3차원 공간을 나타낼 때는 z축이 추가됩니다.

2. 윈도우 좌표계:  
   컴퓨터 그래픽, 특히 Microsoft Windows같은 운영체제에서 사용하는 화면(Screen) 좌표계입니다.  
   윈도우 좌표계의 특징으로는 원점이 화면 왼쪽 위이며 x축은 오른쪽으로 갈수록 값이 커지는 것은 동일하지만 y축이 아래로 갈수록 값이 커진다는 특징이 있습니다.  
   이러한 이유는 초창기 TV나 컴퓨터 모니터가 화면을 위에서 아래로 스캔하면 그리는 방식(Raster Scan)에서 유래했기 때문입니다.  

이 둘의 핵심 차이로 y축이 증가하는 방향에 차이를 가집니다 이로 인해 게임 프로그래밍 등에 수학 공식을 적용해야 할때 y값을 변환해줘야 하는 경우가 많이 생기게 됩니다.  
<br/>

# 게임 프로그래밍의 Update에 대해 설명
게임 프로그래밍의 Update에 대해 설명을 하겠습니다. 이걸 설명하는 이유는 예를 먼저 들어보겠습니다.  
특정 오브젝트를 100pixel 옆으로 이동하라라고 해보겠습니다.  

일반적인 프로그래밍이라면 다음과 같이 작성할 것입니다. (C++ 기준)  
```C++
for(int i = 0; i < 100; i++){
    unit->x = unit->x + 1;
}

Render(unit);
```
하지만 위처럼 작성하게 되면 1프레임 단위로 갱신을 할 수 없게 됩니다. 이게 무슨 소리냐면 위 코드는 동기적으로 실행되게 되어 게임 세계가 멈추게 된다는 뜻입니다.  

이를 해결하기 위해서는 반드시 다음과 같은 방법으로 작성이 되어야 합니다.
```C++
int moveX = 0;

while(1){ // 게임 루프
    // 1프레임

    if(moveX < 100) {
        unit->x = unit->x +1;
        moveX++;
    }
    Render(unit);
}
```

이는 게임 루프에는 방해되지 않고 프레임마다 자연스럽게 오브젝트가 움직이게 될 것입니다.  
이것을 Update Methos Pattern이라고 부르게 됩니다.  
그러나 이것은 컴퓨터의 성능에 따라 플레이 화면이 달라지는 문제를 야기할 수 있습니다.  
이것에 대해서는 뒤에서 따로 설명하도록 하겠습니다.  
<br/>

# CPU Bound vs I/O Bound
이번에 설명할 것은 CPU Bound와 I/O Bound에 대해서 설명하겠습니다.  
먼저 각각에 대해 설명을 하도록 하겠습니다.  

CPU Bound (계산 집약적 작업):  
- 작업의 속도가 전적으로 CPU의 성능에 좌우되는 것
- 복잡한 수학 연산, 데이터 암호화/압축, 동영상 렌더링처럼 CPU가 쉴 틈 없이 계속 계산하는 작업
- CPU는 이 작업들 동안 100% 가깝게 사용됩니다.

I/O Bound (입출력 집약적 작업):  
- I/O는 Input/Output, 즉 입출력을 의미합니다.
- 작업의 대부분을 키보드 입력, 하드디스크 파일 읽기/쓰기, 네트워크 통신 등 느린 외부 장치를 기다리는데 시간을 보내는 작업
- CPU는 이러한 느린 작업이 끝나기를 기다리는 동안 아무것도 하지 않고 그냥 놀게 됩니다. 이것을 CPU idle time이라고 합니다. CPU는 1초에 수십억 번 연산이 가능한데 이러한 시간을 기다리는 것은 엄청난 낭비라고 할 수 있습니다.

그렇다면 위에서 말한 Update Method Pattern의 필요성을 여기서도 느낄 수 있게 됩니다. 만약 플레이어의 키보드 입력을 기다리거나 하는 등의 느린 작업을 수행하는 동안 CPU가 놀게 되면 결국 그 시간동안 게임은 멈춘 것처럼 느껴지게 될 것입니다. 그렇기에 비동기 프로그래밍은 I/O Bound 작업으로 인해 발생하는 CPU idle time을 없애기 위한 핵심 기술이라고 볼 수 있습니다.  
<br/>

# 그래픽 출력 (비트맵 사용)
제가 현재 화면에 그래픽을 출력하는 방법은 비트맵 이미지를 Window Api가 제공하는 함수를 이용하여 그리는 것입니다.  

## 비트맵
그럼 비트맵이란 무엇인가?  
비트맵은 이미지를 구성하는 점(픽셀)의 색상 정보가 격자 형태로 저장된 데이터 덩어리입니다.  
이름을 보면 비트(Bit)들의 지도(Map)이란 뜻인걸 알 수 있죠. 간단하게 **메모리에 저장된 픽셀 데이터의 배열입**니다.  

비트맵의 특징으로는 점 하나하나가 정보를 모두 저장하므로 확대 시 계단 현상(깨짐)이 생긴다는 점이 있습니다.  
저희가 흔히 볼 수 있는 BMP, JPG, PNG 파일들이 비트맵 방식의 이미지입니다.

## DC
이번엔 DC에 대해 설명드리겠습니다.  
갑자기 DC가 무엇이냐??  

DC는 **장치 컨텍스트(Device Context)**의 약자로, 그래픽 출력을 위한 모든 정보와 그리기 기능을 가진 객체입니다.

그렇다면 이건 왜 필요한건가?  
DC가 필요한 이유는 프로그래머가 그림을 그려달라는 명령을 내리면, DC가 그 명령을 해석해서 실제 물리 장치(모니터 화면, 프린터 등)에 맞게 그림을 그려주는 중간 다리 역할을 하기에 꼭 필요하다고 할 수 있습니다.  

DC는 그리기 도구의 정보들을 포함하게 됩니다. 펜, 브러시, 글꼴, 그림을 그릴 대상 등의 정보를 포함하게 됩니다.  
즉 DC는 그림을 그릴 대상(캔버스)이자, 어떻게 그릴지를 결정하는 도구(펜, 브러스 등)의 집합인 것입니다.

## 그림을 그리는 방법
화면에 비트맵을 이용한 그림을 그릴때는 Window Api가 제공하는 BitBlt(HDC hdcDest, int XDest, int YDest, int nWidth, int nHeight, HDC hdcSrc, int XSrc, int YSrc, DWORD dwRop)함수를 이용합니다.  

이는 총 9개의 인자를 받는데 각 인자들에 대해 간략히 설명하자면  
1번 파라미터는 복제 대상 즉, 화면에 출력할 대상  
2 ~ 5번 파라미터는 복사 대상의 x, y, width, height  
6번 파라미터는 복사 원본의 DC  
7, 8번 파라미터는 복사 원본의 좌표  
9번 파라미터는 어떻게 복사할지에 대한 정보입니다.  
9번 파라미터에 들어갈 옵션으로는 대상 영역에 복사하는  SRCCOPY, 값을 반전시키는 DSTINVERT, 검은색으로 채우는 BLACKNESS 등이 있습니다.  

게임 세계는 계속해서 업데이트되어야 합니다 그렇기에 그려지는 화면도 업데이트해야합니다. 게임에서 화면을 업데이트하는 방식은 1프레임마다 화면을 새로 그리는 것입니다. 즉, 전에 그려졌던 내용은 전부 지우고 다시 그리는 겁니다.  

그렇다면 위의 얘기들을 봤을때 최종적으로 각 1프레임마다 지웠다 최종 DC(화면)에 그리기를 반복하기만 하면 문제가 없이 작동할 것 같습니다. 저희가 생각하는데로 나오게 될까요? 그건 아닙니다.  

제가 그렇지 않다고 얘기한 이유를 예를 들어 설명을 드리겠습니다.  
여러분이 학교에서 칠판을 사용하는 수업을 듣는다고 생각해보겠습니다. 그렇다면 선생님께서 칠판에 수업 내용을 그려서 설명을 하고 다음 수업을 위해 지웠다를 반복하실 것입니다.  
그렇다면 여러분은 칠판에 내용이 그려졌다 지워졌다하는 과정을 눈으로 보게 됩니다. 이러한 내용을 컴퓨터 그래픽 출력에 가져와보겠습니다. 저희가 최종 DC(화면)에만 그림을 그리게 된다면 저희는 그려졌다가 지워졌다가하는 과정을 계속 눈으로 보게 될 것이고 그것은 일종의 깜빡임의 형태로 나타나게 될 것입니다. 이러한 깜빡임은 "Tearing 현상"이라고 불리고 있습니다.  

이러한 현상이 나타나는 이유는 위에 설명했던 CPU Bound, I/O Bound에 의해서 나타나는 것이라고 보면 되겠습니다.  

이건 어떻게 해결할 수 있을까요? 방법은 간단합니다. 다시 수업을 듣는다는 예로 돌아가서 설명하면 미리 각기 다른 수업 내용이 작성된 칠판을 여러개 준비해놓고 현재 칠판의 수업 내용이 끝나면 다음 칠판을 가져와서 바로 수업을 이어가면 되는겁니다.  

그렇다면 이것을 어떻게 적용할까요?  
이러한 과정을 설명드리겠습니다.  
1. 화면 DC를 얻는다: 먼저 그림을 출력할 최종 목적지인 윈도우 화면의 DC를 얻습니다.
2. 메모리 DC를 만든다: 화면에 그려지기 전 미리 그림을 그려둘 메모리 상의 임시 캔버스를 만듭니다. (이것이 예제의 미리 준비된 칠판들의 역할을 하는 것입니다.) 이때 당연하게도 메모리 DC와 화면 DC는 호환되어야 합니다.
3. 비트맵을 선택한다: 저희가 가진 비트맵(그림)을 메모리 DC에 붙여넣는 것이 필요합니다. (칠판에 내용을 미리 다 작성해놓는 것입니다.)
4. 화면에 복사한다: 최종적으로 BitBlt()함수를 이용해 비트맵이 그려진 메모리 DC의 내용을 화면 DC로 한번에 복사하여. 최종적으로 저희 눈에 이미지가 보이게 되는 것입니다.
   
위의 과정을 후면 버퍼(Back Buffer, 메모리DC)와 전면 버퍼(Front Buffer, 화면DC)를 이용한다고 하여 **Double Buffer Pattern**이라고 합니다.  
<br/>

# 벡터
위에서 게임 프로그래밍에서는 좌표계가 중요하다고 설명했었습니다.  

이제 그 좌표계를 이용하는 벡터에 대해 설명드리겠습니다.

벡터란?  
'크기(스칼라)'와 '방향'으로 구성되는 개념입니다.  
예를 들어 표현하자면 "현재 위치에서 북동쪽으로 5km 이동" 이런 식으로 표현할 수 있습니다.  
위의 예시에서는 크기(5km), 방향(북동쪽)이라고 설정은 해놓았지만 구체적인 주소나 숫자는 존재하지 않습니다.  
하지만 이를 좌표계와 연계해서 보게 되면 좌표계에는 원점(0, 0)와 x, y축이라는 기준선이 존재하고 "복동쪽으로 5km 이동"이라는 벡터를 좌표계 위에 나타냄으로 비로소 "x축으로 약 3.5km, y축으로 약 3.5km 이동"과 같이 숫자로 된 성분 (3.5, 3.5)라는 벡터로 나타낼 수 있게 됩니다.  

벡터는 물리량으로 힘, 속도, 이동 등이 벡터에 해당하게 됩니다.  
벡터 그 자체는 좌표계가 없어도 존재하는 추상적인 개념으로 좌표계는 이러한 벡터나 점의 위치같은 추상적인 개념을 숫자를 이용해 명확하게 표현하고 계산할 수 있도록 만든 기준틀이 되는 것입니다.  

## 벡터 표기법
1. 수벡터(Numeric Vector):  
   대수적으로 벡터를 표기하는 방법으로  스칼라 (크기, 가장 대표적인 예시는 실수)의 순서쌍으로 표기합니다. 이는 위치와 표기법이 동일하다는 특징이 있습니다.  
   ```
   (x)  
   (x, y)  
   (x, y, z)  
   (x, y, z, w)  
   ...

   (1, 0)
   크기: 1
   방향: (1, 0)
   ```

2. 기하벡터(Geometric Vector)  
   기하학적으로 벡터를 표기하는 방법으로 화살표로 표기합니다.  
   화살표가 지향하는 것이 '방향'  
   화살표의 길이가 '크기'입니다.  

## 벡터의 연산
벡터의 연산은 스칼라의 조합으로 만듭니다. 
1. 벡터끼리의 덧셈(뺄셈)  
   ```
   A = (1, 0)
   B = (0, 1)

   A + B = (1, 0) + (0, 1) = (1 + 0, 0 + 1) = (1, 1)
   ```

2. 벡터끼리의 스칼라곱  
   스칼라를 벡터의 각각의 구성 성분에 곱한다.
   ```
   A = (1, 0)
   S = 2

   A * S = (1, 0) * 2 = (1 * 2, 0 * 2) = (2, 0)
   ```

3. 벡터끼리의 곱셈
   1. 내적(Dot Product)  
      A dot B =||A|| * ||B|| * cosT  
      결과값은 스칼라가 나옵니다.  

   2. 외적(Cross Product)  
      A cross B = ||A|| * ||B|| * sinT * U (U는 A와 B에 모두 수직인 단위 벡터)  
      결과는 벡터입니다.  

4. 벡터의 크기  
   자기 자신을 내적하고 제곱근을 구한다.  

5. 벡터의 정규화  
   임의의 크기의 벡터를 크기를 1로 만드는 연산 즉, 단위벡터(크기를 1인 벡터)를 만드는 것이다.  
   해당 벡터에 해당 벡터의 크기 분의 1을 스칼라 곱셈한다.  

### 벡터의 내적과 외적
벡터의 내적과 외적에 대해서 좀 더 자세히 설명하도록 하겠습니다.  

**벡터 내적**:  
내적이란 두 벡터가 얼마나 같은 방향을 바라보고 있는지 그 정도를 하나의 스칼라로 알려주는 연산입니다.  
두 벡터가 얼마나 협력적인가?를 보여주는 것이라고 생각하시면 됩니다.  
결과로는 방향이 없는 수자 값 하나만 나옵니다.  

**내적 계산 방법**:  
1. 성분으로 계산:  
   2D: A(Ax, Ay) dot B(Bx, By) = Ax * Bx + Ay * By  
   3D: A(Ax, Ay, Az) dot B(Bx, By, Bz) = Ax * Bx + Ay * By + Az * Bz  

2. 기하학적으로 계산
   A dot B = ||A|| * ||B|| * cosT  
   ||A||, ||B||는 각 벡터의 크기(길이)이면, T(Theta)는 두 벡터 사이의 각도입니다.  

**내적 해석**:  
내적의 결과값(부호)만 보게 되더라도 두 벡터의 관계를 알 수 있게 됩니다.  
A dot B > 0: 두 벡터 사이의 각도가 90도보다 작다.(예각)  
A dot B = 0: 도 벡터가 90도로 직교한다.(수직)  
A dot B < 0: 두 벡터 사이의 각도가 90도보다 크다.(둔각)  

**벡터 외적**:  
외적이란 두 벡터에 동시에 수직인 새로운 벡터를 만들어내는 연산입니다. 이 연산은 3D공간에서만 의미를 가집니다.  
외적의 결과로 나온 벡터의 방향은 **오른손 법칙**으로 결정되게 됩니다.  
1. 오른손의 검지를 첫번째 벡터(A) 방향으로 향하게 합니다.  
2. 가운뎃손가락을 두번째 벡터(B) 방향으로 향하게 합니다.  
3. 이때 엄지손가락이 가리키는 방향이 바로 새로 생긴 벡터의 방향이 됩니다.  

외적은 교환법칙이 성립하지 않는다는 특징을 같습니다. 즉, A cross B, B cross A는 크기는 같지만 방향이 정반대라는 뜻이 됩니다.  

**결과 벡터의 크기**:  
|A cross B| = ||A|| * ||B|| * sinT  
이 크기는 두 벡터 A와 B가 만드는 평행사변형의 넓이와 같습니다. 만약 두 벡터가 평행하다면 그 값은 0인 0벡터가 됩니다.  
<br/>

# 레퍼런스 카운팅
레퍼런스 카운팅이란 동적할당한 메모리를 관리하는 방법 중에 하나입니다.  

게임 프로그래밍을 할때는 메모리의 이점을 위해 동적으로 메모리를 할당하는 경우가 많습니다. 이때 할당된 메모리를 다 사용한 후에 삭제하지 않거나 주소값만 삭제하여 다시는 참조 불가능한 데이터로 남기는 (이를 댕글링 포인터라고 한다.) 불상사가 생기는 것을 방지하기 위해 동적 할당 메모리를 관리하는 것은 굉장히 중요한 일입니다.  

이러한 문제를 방지하기 위해 참조 카운팅 즉, 레퍼런스 카운팅 방법이 만들어졌습니다. 이는 동적할당한 메모리를 참조하는 구문이 발생할때마다 참조 횟수를 기록하고 삭제할때는 감소 기록을 하여 참조 횟수가 실제로 0이 되는 순간 삭제하는 기법입니다.  

# 입력 관리자
입력 관리자란 사용자의 입력을 관리하는 것입니다. 예를 들어 A, S, D, F, SPACE, 마우스 클릭 등등의 입력들을 관리하는 객체인 것이죠. 만약 입력 관리자가 여러개라면 어떨까요? 이것은 문제가 될 수 있습니다. A라는 입력을 받았을때 각 입력 관리자가 동작하여 여러 개의 작업을 수행하여 원하는데로 프로그램이 실행이 되지 않을 수 있죠. 그렇기에 필요한 것이 바로 **Singleton Pattern**입니다.

## 싱글톤(Singleton Pattern)
싱글톤이란 객체의 최대 생성 갯수를 1개로 제한하는 목적의 패턴입니다.  
주로 자원을 공유하고 데이터를 일관되게 관리해야 할 때 유용하게 사용할 수 있습니다.  

## 싱글톤 패턴 구현
1. 싱글톤 패턴은 먼저 클래스를 작성합니다.  
2. 클래스 내부에 유일한 statice 인스턴스를 작성합니다.  
3. 생성자를 private으로 선언하여 외부에서 생성되는 것을 막습니다.  
4. 외부에서 유일한 인스턴스에 접근할 수 있는 public static 메서드를 제공합니다.  

싱글톤 패턴은 다음과 같은 과정으로 이루어지게 됩니다.  
다음은 예시입니다.  

```C++
class Singletone{
private:
   Singletone(){
      // 생성자를 private으로 만들었다.
   }
public:
// 복사 생성자, 복사 대입 연산자를 모두 금지하여 유일성 보장
   Singletone(const Singletone&) = delete;
   Singletone& operator=(const Singletone&) = delete;
   Singletone(Singletone&&) = delete;
   Singletone& operator=(Singletone&&) = delete;

   // 유일한 인스턴스를 얻는 public static 메서드
   static Singletone& getInstance(){
      // 이 static 지역 변수는 프로그램에서 getInstance()가 처음 호출될 때 단 한 번만 생성됩니다.
      static Singletone instance;
      return instance;
   }

   void Function(){
      // 특정 기능
   }
}
```

## 입력 관리자 추가 설명
제가 작성한 프로그램에서는 *추상화된 이름*과 *실제 키 입력*을 한 쌍으로 대응시켜서 키 입력 정보를 처리했습니다.  

이 방법을 이용한 이유는 실제 키 입력을 변경해도 소스코드 파일의 수정이 일어나지 않게 하기 위함입니다.  

예를 들어보겠습니다. 점프 키를 SPACE에 할당하여 사용하는데 만약 매핑없이 사용하고 있다면 키를 바꿀때 직접 소스코드에서 SPACE를 지우고 특정 다른 키를 집어넣어야합니다.  

그러나 매핑을 이용하여 점프의 추상화된 이름을 JUMP라고 해놓고 이를 SPACE를 이용한다라고 했을때 소스코드에서 직접 수정할 필요없이 SPACE버튼을 다른 버튼으로 치환하면 해결될 일입니다.  

그리고 위의 방식과 빠른 검색을 위하여 Hash(unordered_map)를 이용하여 키 / 값 쌍으로 데이터를 다루게 하였습니다. 이에 대한 설명은 따로 하지 않고 넘어가겠습니다.  

# Frame Time
이번에는 Frame Time에 대해서 설명하겠습니다.  

FPS(Frames Per Second): 1초당 몇 프레인인가?  
Frame Time: 한 프레임에 걸리는 시간  

이렇게 Frame Time이란 한 프레임에 시간이 얼마나 걸리는가를 나타내는 것입니다.  

제가 앞서 Update에 대해 설명할때 컴퓨터의 성능에 따라 플레이가 달라질 수 있다라고 언급한 적이 있습니다. 그 의미에 대해 여기서 설명하도록 하겠습니다.  

## 프레임 기반 진행 vs 시간 기반 진행
**프레임 기반 진행**  

먼저 프레임 기반 진행에 대해 설명드리겠습니다.  
이것이 바로 컴퓨터의 성능에 따라 플레이가 달라질 수 있다고 한 원인입니다.    

예를 들어 1프레임마다 옆으로 1pixel씩 움직여라라고 명령을 내렸다고 해보겠습니다.

초당 10프레임 컴퓨터  
- 초당 10pixel씩 이동

초당 100프레임 컴퓨터
- 초당 100pixel씩 이동

이렇듯 같은 명령을 내리더라도 컴퓨터의 성능에 따라 게임 진행 속도가 달라진다.  

이것을 해결하기 위해 시간 기반 진행이라는 개념이 생겨났습니다.  

**시간 기반 진행**  

시간 기반 진행은 Frame time을 달리 해주어 프레임 기반 진행의 단점을 보완하는 것입니다.  

위의 예를 수정하여 다시 들어보겠습니다.  

초당 10프레임 컴퓨터
- frame time: 1 / 10 <-- 시간 간격
- 초당 1pixel 이동
  
초당 100프레임 컴퓨터
- frame time: 1 / 100 <-- 시간 간격
- 초당 1pixel 이동

프레임 시간은 한 프레임에 걸리는 시간을 말합니다. 즉, 두 프레임 사이의 시간 간격 그렇기에 '틱 카운트'의 차이를 구하여 이를 이용하여 프레임 시간을 구할 수 있습니다.  

이때 시간을 측정하는 도구로는 window api에서 제공하는 고해상도 타이머  
QueryPerformanceFrequency: 1초에 발생하는 틱카운트 갯수  
QueryPerformanceCounter: 호출 시점에 발생한 틱카운트 번호 알아내기  
를 이용할 수 있습니다.  

# 프로토타입 패턴
프로토타입 패턴이란 임의의 값을 가지는 객체를 보다 편리하게 생성하기 위한 목적의 디자인 패턴입니다.  

새로운 객체를 생성하여 계속 같은 값을 넣어주는 것보다 프로토타입 패턴을 이용하여 더 편하게 객체들을 생성할 수 있습니다. 프로토타입 패턴의 가장 핵심이 되는 구현은 clone()함수(복사생성자를 이용)의 정의 구현입니다.  

-----------------------
### 더 다양한 내용들이 있지만 기본에 대해서는 여기까지만 작성하도록 하겠습니다.  
### 제가 수업을 들으며 내용을 다시 상기시키기 위해 작성하는 것으로 미처 오류를 범하는 부분이 있을 수도 있습니다.  
