---
layout: single
title:  "Unreal Engine 4_설명과 변수 선언"
categories: study
---
**언리얼을 공부하고 배우는 입장으로서 내용에 오류가 있을 수 있습니다.**  
**[베르의 게임 개발 유튜브](https://www.youtube.com/@wergia) 영상을 참고하면서 작성하였습니다.**
# 언리얼 엔진이란?
언리얼 엔진이란 미국의 에픽 게임즈에서 개발한 3차원 게임 엔진으로 강력한 그래픽 성능과 다양한 개발 옵션, 시장의 동향에 따른 빠른 변화와 적응 등을 장점으로 실시간 3D 그래픽 제작 분야의 산업을 주도하고 있습니다.  

# 언리얼 엔진에서 기능을 만드는 방법
언리얼 엔진에서 기능을 만드는 방법은 C++과 블루 프린트가 존재합니다.  
각 방법만을 이용하여 게임을 만드는 것도 충분히 가능하지만 C++로 베이스가 되는 게임 기능을 만들고 블루 프린트를 이용하여 C++로 만든 기본 베이스를 가지고 게임의 기능들을 제작하는 방식으로 이 두 방법을 조합하여 이용하면 더욱 강력한 성능을 낼 수 있습니다.  

## 1. C++
프로그래머가 직접 타이핑하여 코드를 작성하는 프로그래밍하는 방법입니다.  
이는 개발자가 주로 이용하게 됩니다.  

## 2. 블루 프린트
눈에 보이는 노드와 노드를 이어 기능의 흐름을 눈으로 보면서 만들어내는 비주얼 스크립팅입니다.  
이는 디자이너가 주로 이용하게 됩니다.  

# C++ 클래스 생성하기
![Image](https://github.com/user-attachments/assets/d166db7e-f2a0-4709-b195-4f4d494101b0)  
언리얼 엔진 프로젝트를 생성하고 왼쪽 위의 파일 탭을 누르면 다음과 같은 창이 나오는데 이때 새로운 C++ 클래스를 선택해줍니다.  

![Image](https://github.com/user-attachments/assets/9cf946e0-56fe-4a68-b8d3-73c683b571ea)  
선택을 해주게 되면 부모 클래스를 선택할 수 있는데 부모 클래스를 선택하면 선택한 부모 클래스의 변수와 함수를 상속받아 사용할 수 있게 됩니다.  
언리얼 엔진 내부에서 미리 구현한 클래스들이 보이게 되고 Actor 클래스를 선택하여 진행하도록 하겠습니다.  

![Image](https://github.com/user-attachments/assets/519f15bb-3d3f-405f-add4-179a3e9c7081)  
클래스를 생성하면 VS가 열리고 이 VS에서 확인해보면 Actor의 소스 파일(.cpp), 헤더 파일(.h) 파일이 생성되게 됩니다.  
헤더 파일은 클래스를 선언하고, 클래스에 속하는 변수와 함수의 원형을 선언하는 용도의 파일이고 소스 파일은 헤더 파일에서 선언된 함수의 몸체를 구현하는 역할입니다.  

![Image](https://github.com/user-attachments/assets/c54feeaa-9866-4c72-acd1-96313a6939ef)  
*헤더 파일*  

![Image](https://github.com/user-attachments/assets/2f61bda1-60f4-40a7-8708-317537987a09)  
*소스 파일*  

헤더 파일을 보게 되면 클래스 이름과 같은 이름을 가진 생성자, BeginPlay 그리고 Tick 함수가 생성됩니다.  
생성자는 클래스의 객체가 생성 시 한 번만 호출되는 함수이며 변수의 기본 값을 설정하는데 사용됩니다.  
BeginPlay 함수는 액터가 배치된 월드에서 게임이 시작되거나 액터가 월드에 스폰되었을 때 한번 호출되는 함수로 게임플레이 로직을 초기화시키는데 사용됩니다.  
Tick 함수는 매 프레임마다 한 번씩 호출되는 함수입니다. 매개변수인 Deltatime을 통해 Tick 함수가 지난 번에 호출된 이 후로 시간이 얼마나 경과한 후에 Tick 함수가 호출되었는지에 대한 시간을 전달받을 수 있습니다.   
Tick 함수는 Actor가 활성화되어 있는 동안 계속해서 호출되기에 게임의 로직 처리에 주로 사용됩니다. 만약 Tick 함수가 필요치 않다면 이를 삭제함으로 게임의 퍼포먼스 향상에 기여할 수도 있습니다.  
Tick 함수 삭제 방법은 헤더 파일과 소스 파일의 Tick 구현부를 삭제하고 소스 파일의 PrimaryActorTick.bCanEverTick = true; 삭제해주면 됩니다.

# 기본 변수 선언하기
클래스가 소유하는 멤버 변수를 만들기 위해서는 헤더 파일에서 선언이 필요합니다.  
변수를 만들고 사용하기 위해서는 변수를 만들 헤더 파일에서 변수의 타입과 변수 인식을 위한 이름을 적어주면 됩니다. 이때 언리얼에서는 특이한 과정이 붙게 되는데 그것은 UPROPERTY()를 앞에 붙이는 것입니다.  
UPROPERTY 매크로는 언리얼 엔진 및 에디터에 이러한 프로퍼티가 있음을 알리고 연결 시 어떻게 작동할지를 지정하기 위함입니다.  
```C++
UPROPERTY()
int32 test_int = 0;
```  

## 기본 변수 타입
기본 변수 타입에는 정수, 소수, 문자열, 논리 자료형이 있습니다.  

### 1. 정수
-1, 0, 1, 2 등과 같은 일반 숫자를 표현하는데 이용하는 타입입니다.  
기본적인 C++에서는 short, int, long 등의 타입이 존재합니다.  
그러나 언리얼에서는 길이가 고정되어 있는 타입을 이용하기에 int8, int16, int32, int64를 제공합니다. 음수값이 필요 없다라고 한다면 각 타입 앞에 u를 붙인 uint8, uint16, uint32, uint64를 이용 하면 됩니다. 이는 음수가 없는 정수형으로 사용되는 비트 수는 각 타입의 숫자와 같기에 uint같은 경우 일반 int보다 더 많은 양의 양수를 표현할 수 있습니다.  
```C++
int8 i8;
int16 i16;
int32 i32;
int64 i64;

uint8 ui8;
uint16 ui16;
uint32 ui32;
uint64 ui64;
```  

이때 각 변수 타입의 최대 값에서 수를 더 더하거나 최솟 값에서 수를 더 빼는 등의 오버플로우, 언더플로우 문제를 주의해야 합니다.  
게임의 최적화를 위해 적절한 범위의 타입을 사용하고 예외처리를 통해 예상 범위를 벗어나는걸 막게 예방하는 것이 좋습니다.  

### 2. 부동소수점
0.12, 3.14 등과 같은 소수를 표현하는데 이용하는 타입입니다.  
기본적으로 C++과 같이 float, double이 존재합니다.  
float은 32비트이며 소수점 5자리까지의 정밀도를 가지고 double은 64비트로 소수점 10자리까지의 정밀도를 가집니다.  
```C++
float fl;
double db;
```

### 3. 문자열
언리얼 C++는 필요에 따라 여러가지 클래스로 문자열을 제공합니다.  
기본으로는 FString으로 저장되는 글자의 숫자에 따라서 변수의 길이가 자동으로 달라지는 타입으로 기본 C++의 std::string과 유사하게 동작합니다.  
기본 C++에서는 ""를 이용하여 문자열을 저장하지만 FString에서는 Text()매크로를 이용하여야 합니다.  
다른 클래스의 문자열로는 현지화 텍스트를 위해 사용하는 FText, 자주 사용되는 문자열을 식별자로 지정하여 문자열을 비교할 때 소모되는 메모리와 CPU 시간을 절약하는데 쓰이는 FName, 플랫폼마다 다를 수 있는 문자열 세트와 상관없이 문자열을 저장하는 용도로 사용되는 TCHAR가 있습니다.  
기본인 FString을 제외하곤 따로 다루지 않겠습니다.  
```C++
FString str; 
```

### 4. 논리 자료형
기본 C++과 같은 bool을 이용하여 true나 false를 저장합니다.
```C++
bool b;
```

## 변수의 공개 범위
변수의 공개 범위란 모두에게 보여줄건지 상속 받는 자식 클래스에게만 보여줄건지 아니면 본인 클래스 내부에서만 사용할 것인지를 나타내는 것입니다.  
이를 접근 지정자를 통해 설정을 해줄 수 있는데 모두에게는 public을 자식에게만은 protected를 본인만은 private을 이용합니다.  
```C++
public:
    int8 a;
protected:
    int8 b;
private:
    int8 c;
```

## UPROPERTY
위에서 이야기했던 UPROPERTY에 대해 자세히 설명하도록 하겠습니다.  
public 접근 지정자를 이용한 각 프로퍼티마다 앞에 UPROPERTY() 매크로를 붙여줍니다. 이는 언리얼 엔진 및 에디터에 해당 프로퍼티를 노출되게 해주고 어떻게 작동할지를 지정하기 위함입니다.  
그렇다고 UPROPERTY()만 앞에 붙인다고 바로 언리얼 에디터에서 프로퍼티가 보이는 것이 아닙니다.  
프로퍼티가 에디터에 보이게 하기 위해서는 UPROPERTY() 매크로에 필요한 지정자를 넣어줘야 합니다.  

지정자는 많은 종류가 있지만 기본이 되는 것들을 먼저 보게 되면:  
* BlueprintReadWrite -> 블루프린트 내에서 읽기 쓰기 가능  
* BlueprintReadOnly -> 블루프린트 내에서 읽기만 가능  
* EditAnyWhere -> 아키타입(인스턴스화되지 않은 블루프린트의 원본)이나 인스턴스 양쪽의 프로퍼티 창에서 편집할 수 있다  
* Categry = "" -> 이 프로퍼티를 블루프린트 편집 툴이나 디테일 패널에서 특정 카테고리로 묶겠다  
* VisibleAnywhere -> 모든 프로퍼티 창에서 보이지만 편집 불가  
* Transient -> 해당 프로퍼티는 휘발성으로 저장되지 않음  

```C++
UPROPERTY(EditanyWhere, BlueprintReadWrite, Category = "test")
int32 test_int = 0;
UPROPERTY(VisibleanyWhere, BlueprintReadOnly, Category = "test")
FString test_string = TEXT("test_string");
```

![Image](https://github.com/user-attachments/assets/90d86c43-d003-4821-aabb-9ab009c0b064)  
Test_int 프로퍼티는 수정가능하지만 Test_String 프로퍼티는 수정불가함을 확인 가능합니다.  

## 생성자에서 변수 기본 값 설정
위에서 클래스 이름과 같은 생성자가 존재한다고 하였는데 이 생성자에서 변수의 기본 값 설정이 가능합니다.  
소스 파일로 넘어가서 클래스 이름 앞에 A가 붙은 생성자가 보일 것입니다.  
![Image](https://github.com/user-attachments/assets/7e39da33-f843-4b27-b8b0-c9967ae2f4fe)  

이때 초기값 설정법은 2가지가 있는데 첫번째는 생성자 옆에 콜론을 입력하여 프로퍼티의 이름을 적고 괄호에 기본 값을 넣는 것이고 두번째는 생성자의 바디에서 기본 값을 대입해주는 것입니다.  
```C++
# 1.
Atest_actor::Atest_actor() : test_int(30), test_string(TEXT("Constructor_Test"))
{
}

# 2.
Atest_actor::Atest_actor()
{
    test_int = 30;
    test_string = TEXT("Constructor_Test");
}
```

![Image](https://github.com/user-attachments/assets/4875e459-813c-4bd7-98a6-fa4ebf42318a)  
