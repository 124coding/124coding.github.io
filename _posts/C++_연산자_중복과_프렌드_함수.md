# 연산자 중복과 프렌드 함수
이번에는 연산자 중복과 프렌드 함수에 대해 학습하겠습니다. 프로그래머는 다양한 연산자들을 프로그래밍 시 사용하는데 이를 입맛에 맞게 정의할 수 있다면 다양한 타입마다 다른 기능을 수행하게 할 수도 있어서 유용합니다. 프렌드 함수는 특정 외부 함수가 클래스 내부의 멤버 변수나 함수를 수정할 수 있게 해주는 것인데 자세한 것은 이제 학습해보도록 하겠습니다.  

#### **연산자 중복**
연산자 중복(operator overloading)은 개발자가 연산자의 의미를 객체에 대하여 다시 정의할 수 있는 기능입니다. 연산자는 사용자에게 간결하게 의미를 전달할 수 있는 기호로 이를 사용하는 편이 함수보다 이해하기 쉽다는 장점을 가집니다.  

이런 연산자 중복의 예를 들어보자면 다음과 같습니다.  

```C++
int i_1 = 10;
int i_2 = 20;

string s_1 = "Hello ";
string s_2 = "World!";

int i_3 = i_1 + i_2; // i_3 = 30
string s_3 = s_1 + s_2; // s_3 = "Hello World!";
```

위 코드를 보게 되면 같은 + 연산자를 사용하였는데 int 타입인 경우에는 정수 간의 합으로 i_3 변수가 30의 값을 갖게 하였고 string 타입인 경우에는 문자열 2개가 합쳐진 새로운 문자열인 "Hello World!"를 s_3가 가지게 하였습니다. 이 의미는 C++에서는 기초 자료형뿐만이 아니라 다양한 사용자 정의 클래스에서도 연산자의 의미를 확대 사용할 수 있다는 것입니다. 즉, 연산자의 의미가 객체마다 다르게 사용될 수 있다는 것입니다. 그렇기에 이를 연산자 중복이라고 하는 것입니다. 연산자 중복을 사용하면 특정한 클래스마다 적합한 연산자의 의미를 정의할 수 있으며 이는 일종의 다형성 기법으로 볼 수 있습니다. 당연하게도 + 연산자뿐만 아니라 더 다양하고 많은 연산자를 중복하여 사용하는 것이 가능합니다.  

**중복할 수 없는 연산자**  
많은 연산자들이 중복이 가능하듯이 중복이 불가능한 연산자도 존재합니다.  
- :: 범위 지정 연산자
- . 멤버 선택 연산자
- .* 멤버 포인터 연산자
- ?: 삼항 조건 연산자

이들 연산자들은 모두 상당히 중요한 역할을 하는 연산자이기에 중복 정의를 금지합니다.  

#### **연산자 중복의 기초**
연산자를 중복하려면 다음과 같은 형식을 사용합니다.  

```C++
반환형 operator연산자(매개 변수 목록){
    ...
}
```

중복된 연산자는 특수한 이름을 가진 함수라고 생각하시면 됩니다. 즉, 키워드 operator에 연산자 기호가 붙어 있는 함수로 함수는 중복이 가능하고 따라서 연산자도 중복이 가능한 것입니다.  

그렇다면 연산자 중복에 대한 정의는 어디서 해야할까요? 연산자도 근본적으로는 클래스에 속하는 것으로 보아야 합니다. 그렇기에 멤버로 정의하는 것이 원칙이지만 프렌드 함수를 이용하여 클래스의 외부에서 정의될 수도 있습니다. 프렌드 함수는 이번 포스팅의 뒤에서 확인하겠습니다.  

+연산자를 한번 중복해보겠습니다. 

```C++
class MyClass{
    int x, y;

public:
    MyClass(int x, int y) : x(x), y(y){

    }

    MyClass operator+(const MyClass& c2){
        MyClass c;
        c.x = this->x + c2.x;
        c.y = this->y + c2.y;

        return c;
    }
};

int main(){
    MyClass c1(10, 20);
    MyClass c2(5, 5);

    MyClass c3 = c1 + c2;

    return 0;
}
```

위처럼 +연산자 중복을 사용하여서 새로운 객체인 c3를 만들었습니다. 혹시 여기서 의문점이 생기신게 있으실까요? 저는 이 예시 코드를 보고 학습 중에 의문이 생긴 것이 있어서 한번 찾아본 적이 있습니다. 저는 이 코드를 보고 어떻게 + 연산자 중복에서 c2의 멤버 변수와 c의 멤버 변수에 직접 접근을 한 것인지가 궁금했었습니다. x, y는 private으로 설정되었는데 따지고 보면 c2의 외부에서 x, y를 c의 외부에서 x, y를 접근했다고 생각이 들었기 때문입니다. 이에 대해서 찾아보니 답을 얻을 수 있었습니다.  

제가 알아낸 답은 C++의 접근 지정자 규칙은 객체 단위가 아니라 클래스 단위로 적용되기 때문이란 것입니다.  

클래스 단위 접근 규칙이란? MyClass의 멤버 함수라면, 다른 MyClass 객체의 private 멤버에도 접근이 가능하다는 의미로 컴파일러는 operator+가 MyClass의 일부라는 것을 알기에 이 함수 안에서는 operator+를 호출한 자기 자신(this)의 멤버 뿐만 아니라 매개 변수로 들어온 c2나 지역 객체인 c처럼 MyClass 타입의 다른 모든 객체의 private 멤버에도 자유롭게 접근할 권한을 부여하기 때문에 접근이 가능하게 되는 것입니다.  

이렇게 +연산자 중복을 하였듯이 다른 산술 연산자의 중복도 충분히 가능할 것입니다.  

#### **== 연산자 중복**  
일반적으로 == 연산자는 두 개의 객체가 동일한 데이터를 가지고 있는지를 체크하는데 사용됩니다. 즉, 각 멤버 변수의 값을 비교하여서 일치하는 지를 검사하게 됩니다.  

두 개의 객체가 같은지를 따로 검사하는 함수를 두기보다는 == 연산자를 중복하는 편이 더 좋습니다. 그 이유는 표준 라이브러리를 사용할 때 == 연산자가 정의되어 있다면 find()와 같은 라이브러리 함수를 쉽게 사용할 수 있기 때문입니다. 또한 == 연산자가 정의되어 있으면 != 연산자도 당연히 정의하는 편이 혼란을 일으키지 않습니다.  

```C++
class MyClass{
    ...
    bool operator==(const MyClass& c2){
        return (this->x == c2.x && this->y == c2.y);
    }

    bool operator==(const MyClass& c2){
        return !(this == c2);
    }
};
```

#### **++ 연산자 중복**
증가 또는 감소 연산자도 얼마든지 중복이 가능합니다. 이 연산자들은 다른 연산자들과 달리 피연산자의 개수가 한 개라는 점입니다. 이때 고려해야할 점은 전위 연산자와 후위 연산자에 차이를 둬야 한다는 것입니다.  

**전위 연산자**  
전위 연산자로 ++를 정의하는 것은 어렵지 않습니다. 코드를 먼저 보겠습니다.  

```C++
class MyClass{
    ...
    MyClass& operator++(){
        ++this->x;
        ++this->y;

        return *this;
    }
    ...
};
```

일단 반환형을 보면 참조자가 붙어 있음을 확인할 수 있습니다. 왜 그럴까요? ++연산자는 연속하여 적용될 수 있고 이는 객체 자기 자신의 수정이 필요하기에 이를 위해 현재 객체의 참조자를 반환하게 되는 것입니다. 그리고 반환을 할 때 *this를 사용하는 것을 확인하실 수 있습니다. this는 자기 자신을 가리키는 포인터이기에 *this는 객체 자체가 되는 것입니다. 왜 이렇게 반환을 할까요? 그 이유는 연속적으로 ++연산자가 사용이 가능하게 해야하기 때문입니다.  

```C++
MyClass c;
++(++c);
```

안 쪽의 ++c가 참조값을 반환해야만 맨 앞의 ++ 연산이 제대로 실행되는 것입니다.  

그렇다면 반환형이 참조자가 없다면 어떻게 될까요? 이는 반환 시 복사 생성자를 이용하여 복사된 객체를 반환하기에 원본 객체의 멤버 변수 값이 변하지 않는 결과를 나타낼 것입니다.  

**후위 연산자**  
후위 연산자의 경우는 전위 연산자와 다릅니다. 바로 후위 연산자는 그 줄의 명령이 끝난 후 마지막으로 값을 올려주게 된다는 점입니다. 후위 연산자 ++를 중복 정의하는 것은 컴파일러 입장에서는 상당히 도전적인 작업이 되게 됩니다. 왜냐하면 전위와 후위를 구분해야 하기 때문입니다. 후위 연산자 ++의 연산자 중복은 다음과 같이 작성될 수 있습니다.  

```C++
class MyClass{
    ...
    const MyClass operator++(int i){
        MyClass temp = {*this};
        ++this->x;
        ++this->y;
        return temp;
    }
}
```

여기서 매개 변수로 받은 i는 아무런 의미가 없으며 전혀 사용되지 않습니다. 이는 전위와 후위를 구별하기 위함입니다.  

operator++는 참조자가 아닌 객체 복사본을 반환합니다. ++ 연산자가 뒤에 실행되어야 하므로 현재 객체를 따로 보관한 후에 x, y를 증가시키고 보관된 객체를 반환하는 것입니다. 이때 반환되는 타입에 const가 붙어서 반환된 임시 객체는 변경이 불가능하다는 특징을 가집니다. 따라서 다음과 같이 작성하는 것은 오류가 나게 됩니다.  

```C++
(c++)++;
```

이것은 기존의 ++연산자와의 호환성을 위한 것입니다.  

#### **대입 연산자의 중복**
객체 간의 대입 연산도 연산자 중복을 통하여 이루어집니다. 대입 연산자는 조금 특별한데 프로그래머가 따로 대입 연산자를 정의하지 않더라도 컴파일러가 자동으로 생성되고 이것을 통하여 객체 간의 대입 연산이 이루어집니다. 기본 대입 연산자는 단순히 모든 멤버를 다른 객체로 복사하는 것입니다.  

만약 본인만의 대입 연산자가 필요하다면 이는 충분히 작성이 가능합니다.  

```C++
class MyClass{
    ...
    MyClass& operator=(const MyClass& c2){
        this->x = c2.x;
        this->y = c2.y;

        return *this;
    }
};
```

여기서 반환값이 ++전위 연산자처럼 참조자임을 확인할 수 있습니다. 이는 왜 그럴까요? 이것 또한 연속적인 연산을 가능케 하기 위함입니다. 참조자가 없어도 연속적인 연산이 가능하긴 합니다. 그러나 그때마다 불필요한 복사 생성자를 호출하여 생성과 소멸을 계속 반복하게 되어 성능의 저하를 일으킬 수 있습니다. 또한 현재 객체에 대한 후속적인 연산이 불가능할 수 있습니다.  

```C++
MyClass a, b, c;
c = a = b;
```

대입 연산자를 그저 값 복사만으로 사용하면 복사 생성자에서 일어났던 문제인 얕은 복사가 생길 수도 있습니다. 이는 동적 할당 메모리에 대해 깊은 복사를 이용하면 해결되는 문제로 충분히 해결하실 수 있으리라 생각됩니다.  

#### **인덱스 연산자 []의 중복**
인덱스 연산자 []은 번호를 가지고 해당되는 요소를 찾는 연산자입니다. 이러한 인덱스 연산자 또한 중복 정의하여 원하는 기능을 수행하도록 할 수 있습니다.  

```C++
class MyClass{
    int numbers[10];
    ...

    int& operator[](int i){
        if (i >= 10){
            cout << "인덱스 오류";
            return numbers[0];
        }
        return numbers[i];
    }
};
```

다음과 같이 작성이 가능합니다. 이때 인덱스 연산자의 중복 정의 또한 반환형이 참조자임을 알 수 있는데 참조자를 이용하게 되면 대입 연산자의 왼쪽과 오른쪽에 모두 사용할 수 있게 됩니다.  

#### **프렌드 함수**
클래스 안에서 private으로 선언된 멤버들은 내부 데이터를 저장하고 있고 외부에서는 이를 접근할 수 없습니다. 그러나 어떤 경우에는 특정 함수나 클래스가 내부 데이터에 접근할 수 있도록 만드는 것이 효율적입니다. C++에서는 프렌드(friend)라는 메커니즘을 이용해서 외부의 클래스나 함수가 내부 데이터를 사용하도록 허락할 수 있습니다.  

프렌드는 전역 함수일수도 어떤 클래스의 멤버 함수일 수도 혹은 클래스 전체일 수도 있습니다. 특정한 클래스를 프렌드로 지정하면 그 클래스의 모든 멤버 함수는 내부 데이터를 참조할 수 있습니다.  

```C++
class MyClass{
    friend void sub(MyClass& c);
    ...
};

void sub(MyClass& c){
    c.x--;
    c.y--;
}
```

다음과 같이 함수를 프렌드로 설정하면 이제 외부의 sub 함수에서는 MyClass 객체의 내부 데이터를 가져다 쓸 수 있게 됩니다. 프렌드 함수 선언은 클래스의 멤버가 아니기에 접근 지정자의 영향을 받지 않습니다. 클래스 또한 다음과 같이 내부에 프렌드로 선언하여 외부에서 정의하면 내부 데이터를 가져다 사용할 수 있습니다.  

프렌드 함수는 두 개의 객체를 비교할 때 많이 사용됩니다. 2개의 객체를 비교하는 함수를 프렌드 함수로 만들고 외부에 정의해놓으면 이제 두 개의 서로 다른 객체를 비교할때 편하게 내부 데이터를 가져와서 비교할 수 있기 때문입니다. 비슷한 이유로 두 개의 객체 연산 시에도 많이 사용됩니다.  

이러한 프렌드 함수나 클래스는 객체 지향의 정보 은닉을 배반하는 행위이기 때문에 반드시 필요한 경우에만 사용되어야 합니다.  

#### **<< 연산자의 중복**
객체 자체를 << 연산자를 이용해서 출력할 수 있을까요? 객체가 만약 다양하고 많은 멤버 변수를 갖는데 이를 하나하나 접근해서 출력하려면은 작성하기도 불편할 것 같습니다. 그냥 객체에 대해 << 연산자 한 번이면 다 출력할 수 있다면 좋을 것 같습니다. 이를 위해 << 연산자도 중복하여 사용할 수 있습니다. cout은 ostream 클래스의 객체입니다. 따라서 멤버 함수로 추가를 하려면 ostream 클래스 안에 operator<<() 함수를 추가하여야 합니다. 하지만 컴파일러가 제공하는 라이브러리에 속하는 ostream 클래스를 변경할 수는 없습니다. 따라서 프렌드 함수 형태로 본인의 클래스 안에 연산자 <<를 중복 정의할 수 밖에 없습니다.  

<< 연산자 중복 시 ostream 참조자를 반환하여야 합니다. 그렇지 않으면 연속적으로 사용되었을 경우 제대로 작동하지 않을 수 있기 때문입니다.  

```C++
friend ostream& operator<<(ostream& os, const MyClass& c){
    os << c->x << " " << c->y << endl;

    return os;
}
```

**>> 연산자의 중복**
이는 << 연산자와 비슷한 과정을 거칩니다.  

```C++
friend istream& operator>> (istream& in, MyClass& c){
    in >> c->x >> c->y;
    if(!in) c = MyClass(0, 0);

    return in;
}
```

주의점으로는 2번째 매개 변수를 const 즉, 상수화하면 안됩니다. 입력 연산자 입력 시에 발생되는 오류를 대비하기 위해서입니다. 입력에 오류가 발생하면 c를 초기화시켜주게 됩니다.  

#### **연산자 중복 시에 유의할 점**
- 새로운 연산자를 만드는 것은 허용되지 않습니다.
- 거의 모든 연산자 중복이 가능합니다 앞 전에 말씀드린 ::, .*, ., ?: 연산자들만 제외하면 말입니다.
- 중복된 연산자는 클래스 타입의 피연산자를 반드시 가져야 합니다. 즉 내장된 int형이나 double형 등에 대해서는 연산자의 의미를 변경할 수 없습니다.
- 연산자들의 우선순위나 결합 법칙은 변경되지 않습니다.
- 만약 + 연산자를 중복하였다면 일관성을 위해 -, +=, -= 연산자도 중복하는 것이 좋습니다.

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*