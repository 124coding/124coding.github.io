# 함수
함수(function)란 특정 작업을 수행하여 그 결과를 반환하는 블랙박스와 같은 것입니다. 이미 만들어진 함수를 사용하는 것도 물론 가능하고 프로그래머가 직접 함수를 작성하여 사용하는 것도 가능합니다. 각 함수는 레고 블록처럼 다른 함수들과 연결될 수 있으며 심지어는 다른 프로그램에서도 사용될 수 있습니다. 함수를 사용한다면 코드의 재활용 가능,가독성 증대, 유지 관리 용이 등의 많은 장점이 존재합니다.  

```C++
// 두 수 중 더 큰 수를 반환하는 MAX 함수
int MAX(int x, int y){
    if(x > y) return x;
    else return y;
}

// 하나하나 분석해보면
// int MAX(int x, int y) 에서 
// 가장 앞의 int는 반환형으로 이 함수가 반환하는 값의 타입
// MAX는 함수의 이름
// (int x, int y)는 매개 변수(parameter)로 함수의 입력을 전달하는 변수
```

함수를 정의할 때는 함수가 반환하는 값의 유형을 먼저 적어줍니다. 이를 함수의 반환형(return type)이라고 합니다. MAX는 int형을 반환하기에 int가 작성된 것입니다. 이어서 함수의 이름을 작성하고 다음으로 매개 변수(parameter)들을 차례대로 적어줍니다. 매개 변수는 함수의 입력을 전달하는 변수입니다. 함수의 몸체는 중괄호 {...}로 둘러싸인 부분입니다. 여기에는 두 수 중 더 큰 수를 반환하는 내용이 작성되어 있습니다.  

함수를 정의하는 목적은 함수를 사용하기 위함입니다. 그렇다면 함수는 어떻게 사용할 수 있을까요? 함수의 이름을 작성하고 함수가 필요로 하는 데이터를 나열한 후에 세미콜론(;)을 붙이면 됩니다. 이것을 함수 호출(function call)이라고 부릅니다.  
함수가 호출되면 함수 안의 문장들이 순차적으로 실행되며 문장들의 실행이 끝나면 호출한 위치로 되돌아가게 됩니다. 이때 작업의 결과값을 호출한 곳으로 전달할 수 있습니다.  

#### **함수 원형**
일반적으로 함수를 사용 시에는 미리 컴파일러에게 함수에 대한 정보를 알려야 합니다. 이를 함수 원형(function prototype)이라고 합니다. 함수 원형을 함수가 사용되기 전에 정의되어야 하며 함수 원형은 함수의 이름, 매개 변수, 반환형을 함수가 정의되기 전에 미리 한번 써주는 것입니다.  

```C++
int Plus(int x, int y); // 함수 원형 선언

int main(){
    ...
    result = Plus(x, y);
    ...
}

int Plus(int x, int y){
    return x + y;
}
```

그렇다면 이러한 함수 원형은 왜 필요할까요? 함수 원형은 컴파일러에게 미리 함수에 대한 정보를 주어서 함수의 매개 변수 검사, 반환형 검사 등을 하게 하기 위함입니다. 만약 함수 원형이 없다면 함수가 어떤 매개 변수를 가지는지 반환형은 무엇인지를 전혀 알 수 없고 따라서 컴파일러가 해야 할 중요한 검사를 할 수가 없게 되기 때문입니다.  

#### **함수 호출 시 인수 전달 방법**
함수의 매개 변수에 인수를 전달할 때는 2가지의 방법이 있습니다.  
1. 값으로 호출하기(call-by-value): 함수 호출 시 인수의 값이 매개 변수로 복사
2. 참조로 호출하기(call-by-reference): 원본 인수가 함수에 전달되는 방법, 이때 매개 변수의 값을 함수 내에서 수정하면 원본 인수가 변경

- **값으로 호출하기**  
이 방법에서는 함수에 전달되는 것은 인수의 값입니다. 이 말은 무엇이냐. 인수의 값 즉, 인수 자체가 넘어가는 것이 아닌 값만 복사되어 매개 변수에 그 값이 복사되는 것입니다. 이것은 인수를 전달하는 가장 기본적인 방법으로 매개 변수의 값이 바뀐다고 하여서 원본 변수의 값이 바뀌지는 앖습니다.  

- **참조로 호출하기**  
어떤 경우에는 함수 내부에서 외부 변수를 변경할 필요가 있습니다. 이때 사용하는 것이 "참조에 의한 호출"입니다. C++에서는 포인터를 사용하지 않고도 참조자(reference)를 이용하여 참조에 의한 호출을 구현할 수 있습니다. 이러한 참조자는 변수의 별명이라고 생각하시면 됩니다.  

```C++
int var = 10;
int &ref = var;
```

위처럼 작성하게 되면 ref는 var의 별명(alias)가 되어 ref의 값을 바꾸게 되면 var의 값도 바뀌게 됩니다. 이때 &연산자는 포인터 개념에서의 주소 연산자와 똑같이 생겨 헷갈릴 수 있는데 이는 다른 연산자로써 말 그대로 var에 ref라는 이름표를 붙이는 것일뿐 다른 의미는 없습니다.  

코드 자체에 원본 변수의 이름이 있는데 참조자는 왜 필요한 것일까요? 이러한 참조자는 코드 자체적으로 사용되기 보다는 바로 "참조로 호출하기"에 사용됩니다.  

```C++
void Square(int& x){ // void는 반환형이 없다는 의미
    x = x * x;
}

int main(){
    int i = 2;
    Square(i);

    return 0;
}
```

함수를 다음과 같이 정의하여서 사용한다면 참조자에 의해 i의 값은 2 -> 4로 수정될 것 입니다. 이렇듯 함수 내부적으로 외부 변수의 값을 바꿔야할때 참조자가 사용됨을 알 수 있습니다.  

#### **중복 함수**
C++에서는 같은 이름의 함수를 여러 개 정의하는 것도 가능합니다. 이름이 같은 함수라면 오류가 날 것 같은데 이게 어떻게 가능한 걸까요? 이름이 같아도 매개 변수의 형태를 다르게 함으로 구별이 가능하게 할 수 있기 때문에 동일한 이름의 함수를 여러개 정의하는 중복 함수(overloaded functions)는 가능한 것입니다.

#### **디폴트 인수**
함수 호출 시에는 모든 매개 변수에 대하여 값을 전달하여야 합니다. 인수의 개수가 몇 개이든간에 모든 인수에 대하여 값을 주어야 함수가 원하는 대로 동작하며 오류를 발생시키지 않습니다. 그렇다면 매개 변수를 넣는걸 깜빡하거나 아니면 특정 값이 해당 함수의 인수로 많이 사용되어서 미리 매개 변수를 해당 인수 값으로 정의해놓고 특별한 경우에만 값을 갈아치우는 방법은 없을까요? 다행히도 C++에서는 인수를 전달하지 않을 때에도 미리 정의되어 있는 디폴트값을 넣어주는 디폴트 인수(default argument)라는 기능이 존재합니다.  

```C++
// x와 y를 모두 작성하지 않으면 오류
void sum(int x, int y){
    cout << x + y << '\n';
}

// x와 y의 값을 작성하지 않아도 오류 발생 X
void sum(int x = 10, int y = 10){ // x와 y는 각각 10이라는 디폴트 값을 가져서 매개 변수에 인수 값이 들어오지 않더라도 10의 값을 가짐.
    cout << x + y << '\n';
}

sum() // 이렇게만 작성하여도 20을 출력
```

디폴트 인수는 위처럼 모두 다 정의할 수도 있지만 부분적인 매개 변수에만 적용할 수도 있습니다. 그런데 이때 주의할 점이 있습니다. 그것은 디폴트 인수는 무조건적으로 맨 뒤에서부터 들어가 있어야만 합니다.

```C++
// 다음은 오류를 발생시킨다.
void sum(int x = 10, int y){
    ...
}

// 다음은 오류를 발생시키지 않는다.
void sum(int x, int y = 10){
    ...
}
```

#### **인라인 함수**
함수 호출 시에는 약간의 오버헤드가 발생할 수 있습니다. 함수 호출 전에는 모든 레지스터(CPU안의 저장 공간)가 저장되어야 하고 인수들을 복사하여야 합니다. 함수가 호출된 뒤에는 레지스터들이 다시 복구될 필요가 있습니다. 함수가 호출될 때에는 늘 이런 준비 과정이 필요하게 됩니다. 만약 함수가 아주 간단한 함수라면 어떨까요? 이런 준비하는 시간이 함수를 실행시키는 시간보다 많이 걸릴 수도 있게 되는 것입니다. 따라서 크기가 작은 함수라면 함수 호출보다는 해당 함수의 코드를 복사하여 넣어주는 편이 효율적일 수 있습니다.  

C++에서는 이런 경우를 대비하여서 inline이라는 키워드가 준비되어 있습니다. 만약 함수 앞에 inline이 붙어있다면 이 의미는 컴파일러는 함수를 생성하지 않고 함수를 호출한 곳에 해당 함수의 코드를 직접 집어넣는다.라는 의미입니다. 이러한 함수를 인라인 함수(inline function)라고 합니다. 이렇게 작성하게 되면 함수 호출 오버헤드가 사라지므로 프로그램이 더 빠르게 동작할 수 있습니다.

```C++
inline void sum(int x, int y){
    cout << x + y << '\n';
}
```

# 문자열
문자열이란 "Hello!"와 같이 문자들의 나열(sequence)입니다. C언어에서는 char형 배열로 문자열을 나타내지만 C++에서는 string 클래스를 이용하여서 문자열을 쉽게 저장하고 처리할 수 있습니다. 여기서 클래스가 뭐지?라고 생각하실 수 있지만 이는 추후에 학습할 내용이기에 객체 지향의 핵심 개념이란 것만 인지하시고 넘어가시면 됩니다. 아주 간단하게 string 클래스와 객체에 대해서만 알아보겠습니다.  

#### **string 클래스**
string은 문자열을 나타내기 위하여 작성된 클래스로 이러한 string 클래스 안에는 문자열 저장 및 처리에 필요한 변수들과 함수들이 정의되어 있습니다. string 클래스 안에는 문자열 처리에 필요한 다양한 함수들을 제공합니다. 프로그래머들은 이러한 함수들이 내부적으로 어떻게 구현되는지 모르더라도 얼마든지 함수를 사용할 수 있다는 장점이 있습니다.  

#### **string 객체**
클래스는 정수를 나타내는 자료형 int와 같이 사용자가 정의하는 자료형의 일종으로 생각할 수 있습니다. 이를 이용하여 변수를 정의할 수 있게 되고 이것을 객체(object)라고 합니다. 예를 들어 클래스는 와플을 찍어내는 형틀이고 객체가 바로 와플이 되는 것이빈다.  

string 클래스를 사용하려면 string 헤더 파일이 정의되어 있어야 하고 string 클래스는 std 이름 공간에 속해있기에 using 지시어를 사용하여서 std 이름 공간을 사용하겠다고 명시해야 합니다.  

```C++
#include <string>
using namespace std;

string s; // string 객체 s를 생성

string s = "Hello!"; // string 객체를 생성하고 초기화

string s{"Hello"}; // string 객체를 생성하고 초기화
```

#### **문자열의 기능들**
**문자열의 결합**  
string 클래스를 사용하면 두 개의 문자열을 + 연산자를 이용하여 결합할 수 있습니다. C++에서 연산자는 재정의가 가능합니다. + 연산자는 정수를 더하는데 사용되지만 문자열 객체를 더하는 것에도 사용 가능한 것입니다. 이건 연산자 오버로드의 기능으로 추후에 설명할 예정입니다.  

```C++
string subject = "Money";
string other = " good!";

cout << subject + other << '\n'; // Money good! 출력

subject += other;

cout << subject << '\n'; // Money good! 출력
```

**문자열의 비교**  
string 클래스를 사용하면 ==, <, >, <=, >= 연산자들이 기대하는 대로 동작하게 정의되어 있습니다. ==을 이용하면 문자열이 서로 같은지 비교할 수 있고 >, < 연산자를 이용하면 사전적인 순서로 어떤 문자열이 앞에 나오는지를 검사할 수 있습니다.  

**string 클래스를 사용하는 입출력**  
string 클래스도 >> 와 << 연산자를 정의하여서 입출력 연산을 구현하고 있습니다.  

```C++
string s;
cin >> s;
```

다음과 같이 작성하면 s에 문자열을 입력받을 수 있지만 문제가 있을 수 있습니다. 왜냐하면 띄어쓰기 즉, ' '를 기준으로 문자열의 입력이 짤리기 때문입니다. 예를 들어 "나는 공부중입니다."를 입력으로 사용하고 싶은데 "나는"을 치고 띄어쓰기를 하면 입력이 종료되었다고 판단되어 "나는"만 s에 저장되는 것입니다.  

그렇기에 띄어쓰기가 포함된 문자열 전체를 입력 받고 싶다면 getline 함수를 사용하여야 합니다.  

```C++
string s;
getline(cin, s);
```

다음과 같이 작성하게 된다면 "나는 공부중입니다." 문장 전체를 입력 받아 s에 저장할 수 있게 됩니다.  

**멤버 함수 호출**  
string 클래스가 가지고 있는 많은 멤버 함수들을 사용할 수 있습니다. 객체가 생성된 후 객체의 멤버 함수를 호출하려면 도트(.) 연산자를 사용해야 합니다. 예를 들어서 문자열의 크기를 반환 받는 size() 멤버 함수를 사용하려면 다음과 같이 사용하면 됩니다.  

```C++
string s = "Hello World!";
int size = s.size(); // 문자열의 총 길이인 12가 반환
```

이렇듯 유용한 멤버 함수들이 존재하며 string 클래스에는 문자열의 추가, 삭제, 검색을 위한 수 많은 멤버 함수들이 존재합니다. 여기서는 몇 가지만 보이도록 하겠습니다.  

```
s[i]: i번째 원소의 값
s.empty(): s가 비어있으면 true 반환
s.insert(pos, s2): s의 pos 위치에 s2를 삽입
s.remove(pos, len): s의 pos 위치에 len만큼을 삭제
s.find(s2): s에서 문자열 s2가 발견되는 첫번째 인덱스를 반환
s.find(pos, s2): s의 pos 위치부터 문자열 s2가 발견되는 첫번째 인덱스를 반환
```

________________________

*이 포스팅은 어서와 C++는 처음이지(저자 천인국)을 공부하며 작성하는 내용입니다.*  
*학부생 수준에서 작성된 포스팅으로 오류를 최대한 내지 않으려 하지만 오류가 있을 수 있는 부분 미리 양해 말씀드립니다.*